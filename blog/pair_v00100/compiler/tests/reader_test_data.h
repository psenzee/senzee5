#ifndef _READER_TEST_DATA_H
#define _READER_TEST_DATA_H

const char *program = 

"(procedure\n"
"\n"
"  ; NOTES\n"
"  ; - Pair is almost useful!\n"
"  ;\n"
"  ; Priorities?\n"
"  ; X get bytecodes > 128 working\n"
"  ;   X 1 byte LET0-LET7/LET15 (change name of all LET to SETL?)\n"
"  ;   X 1 byte LOCAL0-LOCAL7/LOCAL15\n"
"  ;   - 1 byte LET_NOPOP0-7/15?\n"
"  ; - compile lexical closures!!\n"
"  ; - globals\n"
"  ;   - SETG, GETG\n"
"  ;   - will resolve to an address (ie, &global_pool[index]), like CONST and FUNC\n"
"  ;   - linker will have a global pool that it allocates from \n"
"  ;   - 1 global pool for all 'threads'\n"
"  \n"
"  ;\n"
"  ; X [hacked] arguments are passed backwards on native functions\n"
"  ;   - verify that native fn args TYPES are in correct order..\n"
"  ;   - fix this correctly!\n"
"  ; X got expanding const/let/local/func opcodes working - good job!\n"
"  ; - make the parser understand hex, both as [done] numbers and embedded in strings like \"\\x44\" etc..\n"
"  ; - using let as constants works pretty well, could use optimization (ie, determine what's constant)\n"
"  ; X get bytecodes > 128 working\n"
"  ; - if a let is used as a constant (assigned only once..) and then used in an inner function, we don't need to compile a closure, just substitute in the value \n"
"  ;     [or make it private global - ideal for const functions]\n"
"  ; - if a function uses globals but not local variables from the enclosing scope, we don't need to compile a closure\n"
"  ; - need bitwise operators\n"
"  ; - math operators still only accept two args\n"
"  ; - math operators should work with all math types, not just cast everything to float!\n"
"  ; - pointer a number type?\n"
"  ; - rewrite compiler\n"
"  ;   - in Pair?\n"
"  ;   - fix dotted pairs\n"
"  ;   - special purpose constant for (quote NIL)\n"
"  ;   - simple pair-reader package?\n"
"  ;   - common code between pair and compiler? [hmm.. i don't know..]\n"
"  ;   - locals, globals and constants that are not used compiled out\n"
"  ;   - compiler error reporting is awful\n"
"  ;   - compiler doesn't err in the case of undefined local vars!!\n"
"  ;   - compiler doesn't detect mismatched parens\n"
"  ;   - (of course) compiler doesn't err in the case of undefined functions - we'll need to figure out what to do with that\n"
"  ;   - special compilation for (import ..) [don't evaluate most args]\n"
"  ;   - some (let ..) can be compiled to (constant) [if there's no write-back]\n"
"  ;   - usually global names can be compiled out, (unless they're referenced?)\n"
"  ;   - compile (function x (..) ..) to (define-global x (anonymous-function (..) ..))\n"
"  ;   - we want to remove function names from object code when possible\n"
"  ;   - function names and variables have same namespace, but disallow overriding names of special forms, issue warning for overriding names of built-in functions\n"
"  ; - we need to figure out how to deal with native functions that have IN/OUT params\n"
"  ;   - just return a list with return value as head and tail as list of new values\n"
"  ;   - this will be checked for at compile time and required to be marked up in the return type\n"
"  ; - (define <global-name> <value>), use (set ..) instead of (let ..) for subsequent modifications of locals, use (let ..) to create them\n"
"  ; - use (let .. ) the way it's used in scheme/lisp? - yes!\n"
"  ; - (set ..) can modify <locals>, <globals>. And <constants>?\n"
"  ; - need (set-head ..), (set-tail ..)\n"
"  ; - so we can have (define ..) or (constant <name> <value>) [constant will have local scope, but be accessible in all subscopes]\n"
"  ; - (lazy ..) modifier for delayed evaluation\n"
"  ; - write lots of test cases and a test framework (ie, comparing output)\n"
"  ; - what about arrays and hashes?\n"
"  ; - what about ADDN or MULN or DIVN, etc.?\n"
"\n"
"; (let MB_OK                       0)\n"
"; (let MB_OKCANCEL                 1)  \n"
"; (let MB_ABORTRETRYIGNORE         2)\n"
"; (let MB_YESNOCANCEL              3)\n"
"; (let MB_YESNO                    4)\n"
"; (let MB_RETRYCANCEL              5)\n"
"  (let MB_CANCELTRYCONTINUE        6)\n"
"\n"
"; (let MB_ICONHAND                 16)\n"
"; (let MB_ICONQUESTION             32)\n"
"  (let MB_ICONEXCLAMATION          48)\n"
"; (let MB_ICONASTERISK             64)\n"
"\n"
"; (let MB_USERICON                 128)\n"
"; (let MB_ICONWARNING              MB_ICONEXCLAMATION)\n"
"; (let MB_ICONERROR                MB_ICONHAND)\n"
"\n"
"; (let MB_ICONINFORMATION          MB_ICONASTERISK)\n"
"; (let MB_ICONSTOP                 MB_ICONHAND)\n"
"\n"
"; (let MB_APPLMODAL                0)\n"
"  \n"
"; (let MB_SYSTEMMODAL              0x00001000)\n"
"; (let MB_TASKMODAL                0x00002000)\n"
"; (let MB_HELP                     0x00004000)\n"
"\n"
"; (let MB_NOFOCUS                  0x00008000)\n"
"; (let MB_SETFOREGROUND            0x00010000)\n"
"; (let MB_DEFAULT_DESKTOP_ONLY     0x00020000)\n"
"\n"
"  (let MB_TOPMOST                  0x00040000)\n"
"; (let MB_RIGHT                    0x00080000)\n"
"; (let MB_RTLREADING               0x00100000)\n"
"\n"
"; (let MB_SERVICE_NOTIFICATION     0x00200000)\n"
"\n"
"  (let wait         (import \"msvcrt.dll\"   'cdecl   '_getch      'u \"\"))\n"
"  (let system       (import \"msvcrt.dll\"   'cdecl   'system      'u \"s\"))\n"
"  (let message-box  (import \"user32.dll\"   'stdcall 'MessageBoxA 'u \"ussu\"))\n"
"  (let message-beep (import \"user32.dll\"   'stdcall 'MessageBeep 'u \"u\"))\n"
"  (let sleep        (import \"kernel32.dll\" 'stdcall 'Sleep       'v \"u\"))\n"
"\n"
"; (print \"mb result=\" (message-box (+ MB_ICONEXCLAMATION (+ MB_CANCELTRYCONTINUE MB_TOPMOST)) \"some text\" \"some title\" 0) \"\\n\")\n"
"\n"
"  (print \"mb result=\" (message-box 0 \"some texty\" \"some titley\" (+ MB_ICONEXCLAMATION (+ MB_CANCELTRYCONTINUE MB_TOPMOST))) \"\\n\")\n"
"\n"
"  (message-beep 0)\n"
"\n"
"  (function print ()\n"
"    (let arguments (append (list (standard-out)) (args)))\n"
"    (apply (fn write) arguments))\n"
" \n"
"  (function this-is-my-function (a b c)\n"
"    (print \"A: \" a \" B: \" b \" C: \" c \"\\n\"))\n"
"\n"
"  (print \"Math: \" (+ 13 (+ (+ 12 (* 42 84)) (+ 91 (/ 100 5)))) \"\\n\")\n"
"\n"
"  (let count 0)\n"
"  (foreach (x '(a b c d e f g))\n"
"    (let count (+ count 1.0))\n"
"    (this-is-my-function count x count))\n"
"    \n"
"  (foreach (x \"Hello, my pretties!!!!\")\n"
"    (print \"[\" x \"] \"))\n"
"  (print \"\\n\")\n"
"\n"
"  (print count \"\\n\")\n"
"  \n"
"  (print \"Asking - assoc?\\n\"\n"
"         \" \" '(assoc? (x . y)) \" \" (assoc? '(x . y)) \"\\n\"\n"
"         \" \" '(assoc? (x y)) \" \" (assoc? '(x y)) \"\\n\"\n"
"         \" \" '(assoc? count) \" \" (assoc? count) \"\\n\")\n"
"           \n"
"  (print \"Asking - pair?\\n\"\n"
"         \" \" '(pair? (x . y)) \" \" (pair? '(x . y)) \"\\n\"\n"
"         \" \" '(pair? (x y)) \" \" (pair? '(x y)) \"\\n\"          \n"
"         \" \" '(pair? count) \" \" (pair? count) \"\\n\")\n"
"\n"
"  (print \"Asking - atom?\\n\"\n"
"         \" \" '(atom? (x . y)) \" \" (atom? '(x . y)) \"\\n\"\n"
"         \" \" '(atom? (x y)) \" \" (atom? '(x y)) \"\\n\"          \n"
"         \" \" '(atom? count) \" \" (atom? count) \"\\n\")\n"
"           \n"
"  (print \"Asking - length\\n\"\n"
"         \" \" '(length (x y z a b c)) \" \" (length '(x y z a b c)) \"\\n\"\n"
"         \" \" '(length (x y)) \" \" (length '(x y)) \"\\n\"\n"
"         \" \" '(length count) \" \" (length count) \"\\n\")\n"
"\n"
"  (foreach (x '(1 2))\n"
"    (foreach (y '(1 2))\n"
"      (print x \"  < \" y \"? \" (<  x y) \"\\n\")\n"
"      (print x \"  > \" y \"? \" (>  x y) \"\\n\")\n"
"      (print x \"  = \" y \"? \" (=  x y) \"\\n\")      \n"
"      (print x \" <= \" y \"? \" (<= x y) \"\\n\")\n"
"      (print x \" >= \" y \"? \" (>= x y) \"\\n\")))\n"
"\n"
"  (while (not (ask \"did you get that?\"))\n"
"    (print \"get it yet?\\n\"))\n"
"  \n"
"  (let x (fn ask))  \n"
"  (let y '(\"This is a Question\" \"Answer It!\"))\n"
"  (print \"User answers '\" (apply x y) \"'\\n\")\n"
"  \n"
"  (let   stream (open-out-file \"a-new-file.txt\" \"a\"))\n"
"  (write stream \"hey little file 2!!\\n\")\n"
"  \n"
"  (let   string-stream (open-out-string))\n"
"  (write string-stream \"hola\" \" \" \"bobby\" \" \" \"boy!\" \"\\n\")\n"
"  (print string-stream)\n"
"  \n"
"  (print 'stream \"\t\" stream         \"\\n\"\n"
"         'ask    \"\t\" (fn ask)       \"\\n\"\n"
"         'stdout \"\t\" (standard-out) \"\\n\"\n"
"         'x      \"\t\" x              \"\\n\")\n"
"  \n"
"  (close stream))\n";

const char *basic0 = 

"(procedure\n"
"  \n"
"  (function print ()\n"
"    (let arguments (append (list (standard-out)) (args)))\n"
"    (apply (fn write) arguments))\n"
"    \n"
"  (function println ()\n"
"    (let arguments (append (list (standard-out)) (args) '(\"\\n\")))\n"
"    (apply (fn write) arguments))\n"
"\n"
"  ; these functions are implemented without return (cause I haven't implemented return yet)\n"
"  \n"
"  (function last-member/1 (x s)\n"
"    (let v ())\n"
"    (foreach (y s)\n"
"      (if (= x y) (let v y)))\n"
"    v)\n"
"    \n"
"  (function last-member/2 (x s)\n"
"    (let u s)\n"
"    (let v ())\n"
"    (while u\n"
"      (if (= (first u) x)\n"
"        (let v u))\n"
"      (let u (rest u)))\n"
"      v)\n"
"      \n"
"  (function first-member/2 (x s)\n"
"    (let u s)\n"
"    (let v ())\n"
"    (while u\n"
"      (if (= (first u) x)\n"
"        (procedure\n"
"          (let v u)\n"
"          (let u ())))\n"
"      (let u (rest u)))\n"
"      v)\n"
"\n"
"   (let yo '(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Y X W V U T S R Q P O N M L K J I H G F E D C B A))\n"
"\n"
"   (println \"list          =\" yo)\n"
"   (println \"last-member/1 =\" (last-member/1 'P yo))\n"
"   (println \"last-member/2 =\" (last-member/2 'P yo))\n"
"   (println \"first-member/2=\" (first-member/2 'P yo)))\n";

#endif // _READER_TEST_DATA_H