#include "scheduler_c.h"#include "events_c.h"#include <vector>#include <string>#include <pthread.h>struct ScheduledEvent{    std::string name;    int         ms_into_future;    int         ms_target_time;    bool        recurs;    bool        invalid;        inline ScheduledEvent(const char *name, int ms_into_future, bool recurs)    : name(name), ms_into_future(ms_into_future), ms_target_time(0), recurs(recurs), invalid(false) {}};class Scheduler{    std::vector<ScheduledEvent> events;    int                         current_time;    pthread_mutex_t             lock;        static Scheduler           *INSTANCE;        Scheduler() : current_time(0)    {        pthread_mutex_init(&lock, NULL);    }    public:        void Update(int ms_elapsed)    {        std::vector<std::string> fire;        pthread_mutex_lock(&lock);        current_time += ms_elapsed;        int invalids = 0;        for (std::vector<ScheduledEvent>::iterator i = events.begin(), e = events.end(); i != e; ++i)        {            ScheduledEvent &event = *i;            if (!event.invalid && current_time > event.ms_target_time)            {                fire.push_back(event.name);                if (event.recurs)                    event.ms_target_time = event.ms_into_future + current_time;                else                    event.invalid = true;            }            if (event.invalid)                invalids++;        }        // if more than half are invalid, clean up        if (invalids > (events.size() >> 1))        {            std::vector<ScheduledEvent> list;            for (std::vector<ScheduledEvent>::iterator i = events.begin(), e = events.end(); i != e; ++i)                if (!(*i).invalid) list.push_back(*i);            events = list;        }        pthread_mutex_unlock(&lock);        for (std::vector<std::string>::const_iterator i = fire.begin(), e = fire.end(); i != e; ++i)        {            printf("*** Scheduler [%06d]: firing '%s'\n", current_time, (*i).c_str());            Events_Fire("SCHEDULER", (*i).c_str(), (*i).c_str());        }        Events_Update("SCHEDULER"); // may need to run on different thread    }        void Schedule(const char *name, int ms_into_future, int recurs)    {        ScheduledEvent event(name, ms_into_future, recurs);        event.ms_target_time = event.ms_into_future + current_time;        printf("*** Scheduler [%06d]: scheduling '%s' to execute at %d (now %d)\n", current_time, name, event.ms_target_time, current_time);        pthread_mutex_lock(&lock);        events.push_back(event);        pthread_mutex_unlock(&lock);    }        void Invalidate(const char *name)  // will ultimately be removed    {        pthread_mutex_lock(&lock);        for (std::vector<ScheduledEvent>::iterator i = events.begin(), e = events.end(); i != e; ++i)            if (strcmp((*i).name.c_str(), name) == 0)                (*i).invalid = true;        pthread_mutex_unlock(&lock);    }        static Scheduler *GetInstance()    {        if (!INSTANCE)            INSTANCE = new Scheduler;        return INSTANCE;    }    };Scheduler *Scheduler::INSTANCE = 0;extern "C" void Scheduler_Update(int ms_elapsed){    Scheduler::GetInstance()->Update(ms_elapsed);}extern "C" void Scheduler_ScheduleEvent(const char *event, int ms_from_now, int recurs){    Scheduler::GetInstance()->Schedule(event, ms_from_now, recurs ? true : false);}extern "C" void Scheduler_ScheduleOneEvent(const char *event, int ms_from_now){    Scheduler_ScheduleEvent(event, ms_from_now, 0);}extern "C" void Scheduler_RemoveEvent(const char *event){    Scheduler::GetInstance()->Invalidate(event);}