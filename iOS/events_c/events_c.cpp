#include "events_c.h"#include <stdlib.h>#include <map>#include <string>#include <vector>#include <algorithm>class EventDispatcher{public:    typedef std::string                             string_t;    typedef std::pair<string_t, string_t>           string_pair_t;    typedef std::vector<string_pair_t>              string_pair_list_t;    typedef std::vector<EventHandler>               eventhandler_list_t;    typedef std::map<string_t, eventhandler_list_t> eventhandler_map_t;        EventDispatcher();        void Register  (const char *event, const EventHandler *eh);    void Unregister(const char *event, const EventHandler *eh);        void Fire      (const char *event, const char *info);        void Update();        int  GetQueuedEventCount() const { return (int)mEvents.size(); }    private:        bool FireEventHandler(const string_t &event, EventHandler *handler, const char *info, bool immediate);    bool FireInternal(const string_t &event, const char *info, bool immediate);        eventhandler_map_t mMap;    string_pair_list_t mEvents;};class EventDispatcherRegistry{public:        typedef std::string string_t;    typedef std::map<string_t, EventDispatcher *> dispatcher_map_t;        static EventDispatcherRegistry *Instance();        EventDispatcher *GetDispatcher(const char *name);    private:        static EventDispatcherRegistry *INSTANCE;        inline EventDispatcherRegistry() {}        dispatcher_map_t mDispatchers;};static EventDispatcher *Dispatcher(const char *name){    return EventDispatcherRegistry::Instance()->GetDispatcher(name);}EventDispatcher::EventDispatcher(){}void EventDispatcher::Register(const char *event, const EventHandler *eh){    mMap[event].push_back(*eh);}namespace { // local to this file        struct Match    {        EventHandler e;        inline Match(const EventHandler &e) : e(e) {}        inline bool operator()(const EventHandler &a) const        {            return (e.function == EventHandler_ANY_FUNCTION || e.function == a.function) &&            (e.context  == EventHandler_ANY_CONTEXT   || e.context == a.context);        }    };    }void EventDispatcher::Unregister(const char *event, const EventHandler *eh){    Match m(!eh ? *EventHandler_ANY_HANDLER : *eh);    if (event != EventHandler_ANY_EVENT)    {        eventhandler_list_t &eh = mMap[event];        eh.erase(std::remove_if(eh.begin(), eh.end(), m), eh.end());    }    else    {        for (eventhandler_map_t::iterator i = mMap.begin(), e = mMap.end(); i != e; ++i)        {            eventhandler_list_t &v = (*i).second;            v.erase(std::remove_if(v.begin(), v.end(), m), v.end());        }    }}static void PrintEvents(EventDispatcher::string_pair_list_t &events, const EventDispatcher *ed){    printf("\nevents = %d (%p) -----------\n", (int)events.size(), ed);    for (EventDispatcher::string_pair_list_t::const_iterator i = events.begin(), e = events.end(); i != e; ++i)        printf("%s/%s\n", (*i).first.c_str(), (*i).second.c_str());    printf("-----------\n");}void EventDispatcher::Fire(const char *event, const char *info){    string_pair_t pair(event, info);    mEvents.push_back(pair);    FireInternal(pair.first, info, true); // take care of the immediate events}bool EventDispatcher::FireEventHandler(const string_t &event, EventHandler *handler, const char *info, bool immediate){    if (handler && handler->function &&        ((immediate &&  (handler->flags & EventFlag_Immediate)) ||         (!immediate && !(handler->flags & EventFlag_Immediate))))    {        int result = (handler->function)(handler->context, event.c_str(), info);        return (result && (handler->flags & EventFlag_StopOnTrue));    }    return false;}bool EventDispatcher::FireInternal(const string_t &event, const char *info, bool immediate){    if (mMap.find(event) != mMap.end())    {        eventhandler_list_t &v = mMap[event];        for (eventhandler_list_t::iterator i = v.begin(), e = v.end(); i != e; ++i)            if (FireEventHandler(event, &(*i), info, immediate))                return true;    }    return false;}void EventDispatcher::Update(){    string_pair_list_t events(mEvents);    mEvents.clear();    for (string_pair_list_t::iterator i = events.begin(), e = events.end(); i != e; ++i)        FireInternal((*i).first, (*i).second.c_str(), false);}// RegistryEventDispatcherRegistry *EventDispatcherRegistry::INSTANCE = 0;EventDispatcherRegistry *EventDispatcherRegistry::Instance(){    if (!INSTANCE)        INSTANCE = new EventDispatcherRegistry();    return INSTANCE;}EventDispatcher *EventDispatcherRegistry::GetDispatcher(const char *name){    static string_t ns; // reduce reallocation    ns = name;    EventDispatcher *dispatcher = mDispatchers[ns];    if (!dispatcher)    {        dispatcher = new EventDispatcher();        mDispatchers[ns] = dispatcher;    }    return dispatcher;}extern "C"{        const char       * const EventHandler_ANY_EVENT    = 0;    Event_function_t   const EventHandler_ANY_FUNCTION = 0;        static int _any_context = 0;    const void * const EventHandler_ANY_CONTEXT  = &_any_context;        static EventHandler _any_handler = { EventHandler_ANY_FUNCTION, (void *)EventHandler_ANY_CONTEXT };    const EventHandler * const EventHandler_ANY_HANDLER  = &_any_handler;        EventHandler Events_MakeHandler(Event_function_t function, void *context, int flags)    {        EventHandler eh;        memset(&eh, 0, sizeof(EventHandler));        eh.function = function;        eh.context = context;        eh.flags = flags;        return eh;    }        void Events_Register(const char *dispatcher_name, const char *event, const EventHandler *handler)    {        Dispatcher(dispatcher_name)->Register(event, handler);    }        void Events_Unregister(const char *dispatcher_name, const char *event, const EventHandler *handler)    {        Dispatcher(dispatcher_name)->Unregister(event, handler);    }        void Events_Fire(const char *dispatcher_name, const char *event, const char *info)    {        Dispatcher(dispatcher_name)->Fire(event, info);    }        int Events_QueuedEventCount(const char *dispatcher_name)    {        return Dispatcher(dispatcher_name)->GetQueuedEventCount();    }        void Events_Update(const char *dispatcher_name)    {        Dispatcher(dispatcher_name)->Update();    }    }