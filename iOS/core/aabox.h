#ifndef _AABOX_H#define _AABOX_H#include "tuple3f.h"#include "plane.h"class AABox{public:        enum BoxPlane { BoxPlane_XMin, BoxPlane_XMax,                    BoxPlane_YMin, BoxPlane_YMax,                    BoxPlane_ZMin, BoxPlane_ZMax, BoxPlane_None };            Tuple3f minimum, maximum;            inline AABox(const Tuple3f &a, const Tuple3f &b) : minimum(a.minimum(b)), maximum(a.maximum(b)) {}    inline AABox() : minimum(FLT_MAX, FLT_MAX, FLT_MAX), maximum(-FLT_MAX, -FLT_MAX, -FLT_MAX) {}            inline Tuple3f  size()   const { return maximum - minimum; }    inline bool     empty()  const { return minimum.x >= maximum.x || minimum.y >= maximum.y || minimum.z >= maximum.z; }    inline bool     valid()  const { return minimum.x <= maximum.x && minimum.y <= maximum.y && minimum.z <= maximum.z; }        inline Tuple3f  center() const { return (minimum + maximum) * 0.5; }        inline BoxPlane outside_plane_enum(const Tuple3f &p) const    {        const int PLANE_COUNT = 6;        double limits[PLANE_COUNT] =        {            minimum.x - p.x, p.x - maximum.x,            minimum.y - p.y, p.y - maximum.y,            minimum.z - p.z, p.z - maximum.z        };        int lim = (BoxPlane)(math::min_max_indices(limits, PLANE_COUNT).second);        if (lim == -1 || limits[lim] < 0.0)            return BoxPlane_None;        return (BoxPlane)lim;    }        inline bool    inside(const Tuple3f &p) const    {        return p.x <= maximum.x && p.x >= minimum.x &&               p.y <= maximum.y && p.y >= minimum.y &&               p.z <= maximum.z && p.z >= minimum.z;    }        inline Tuple3f clamp(const Tuple3f &p) const    {        return Tuple3f(math::clamp(p.x, minimum.x, maximum.x),                       math::clamp(p.y, minimum.y, maximum.y),                       math::clamp(p.z, minimum.z, maximum.z));    }        inline void    insert(const AABox &box)    {        insert(box.minimum);        insert(box.maximum);    }    inline void    insert(const Tuple3f &point)    {        minimum = minimum.minimum(point);        maximum = maximum.maximum(point);    }    inline void    expand(const Tuple3f &values)    {        minimum -= values * 0.5f;        maximum += values * 0.5f;    }    inline AABox   overlap(const AABox &box) const    {        return AABox(box.minimum.maximum(minimum), box.maximum.minimum(maximum));    }    inline static Tuple3f normal(BoxPlane plane)    {        switch (plane)        {        case BoxPlane_XMin: return Tuple3f(-1.0,  0.0,  0.0);        case BoxPlane_XMax: return Tuple3f( 1.0,  0.0,  0.0);        case BoxPlane_YMin: return Tuple3f( 0.0, -1.0,  0.0);        case BoxPlane_YMax: return Tuple3f( 0.0,  1.0,  0.0);        case BoxPlane_ZMin: return Tuple3f( 0.0,  0.0, -1.0);        case BoxPlane_ZMax: return Tuple3f( 0.0,  0.0,  1.0);        default: break;        }        return Tuple3f(0.0, 0.0, 0.0);    }    inline Plane plane(BoxPlane plane) const    {        switch (plane)        {        case BoxPlane_XMin: return Plane(-1.0,  0.0,  0.0, minimum.x);        case BoxPlane_XMax: return Plane( 1.0,  0.0,  0.0, maximum.x);        case BoxPlane_YMin: return Plane( 0.0, -1.0,  0.0, minimum.y);        case BoxPlane_YMax: return Plane( 0.0,  1.0,  0.0, maximum.y);        case BoxPlane_ZMin: return Plane( 0.0,  0.0, -1.0, minimum.z);        case BoxPlane_ZMax: return Plane( 0.0,  0.0,  1.0, maximum.z);        default: break;        }        return Plane(0.0, 0.0, 0.0, 0.0);    }    inline Plane outside_plane(const Tuple3f &p) const    {        return plane(outside_plane_enum(p));    }    void print()    {        printf("aabox (%.2f, %.2f, %.2f)-(%.2f, %.2f, %.2f)\n",               minimum.x, minimum.y, minimum.z, maximum.x, maximum.y, maximum.z);    }};    #endif // _AABOX_H