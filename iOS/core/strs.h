#ifndef _STRS_H#define _STRS_H#include <string>#include <string.h>#ifndef WIN32#define stricmp  strcasecmp#define strnicmp strncasecmp#endifvoid          skip_space(const char **s);void          skip_space_not_newline(const char **s);// the is*() and read*() functions below skip preceeding whitespace// is*() - is it a string followed by '\0' or://  a space (is),//  one of the characters specified (is_and_followed_by_any),//  or not one of the characters specified (is_and_not_followed_by_any)?bool          is(const char **s, const char *match, bool ignorecase = false);bool          is_and_followed_by_any(const char **s, const char *match, const char *after, bool ignorecase = false);bool          is_and_not_followed_by_any(const char **s, const char *match, const char *after, bool ignorecase = false);extern unsigned QNAN_FOUND; // this is a hack for read(.., float &) right nowbool          read_quoted(const char **s, char quote, char *buffer, bool escape = false);std::string   read_identifier(const char **s); // $todo we should use a version that's consistent with the two read()'s above (ie, returning a bool, and taking a mutable string as an arg)bool          read(const char **s, float &u);bool          read(const char **s, int &u);bool          read(const char **s, unsigned &u);const char   *find(const char *s, const char *f, bool ignorecase = false);unsigned      count(const char *s, const char *f, bool ignorecase = false);bool          ends(const char *data, const char *substr, bool ignorecase = false);bool          starts(const char *data, const char *substr, bool ignorecase = false);char        **split_char_of(const char *in, const char *of);char        **split_char_of_keep_empty(const char *in, const char *of);void          destroy(char **strlist);const char   *extension(const char *filename);void          replace_char(char *s, char f, char r);void          replace_chars(char *s, const char *f, char r);bool          isspace(const char *s);bool          isdigit(const char *s);bool          isupper(const char *s);bool          islower(const char *s);unsigned      count_char_of(const char *p, char c);unsigned      count_char_of(const char *s, const char *of);bool          composed_of(const char *s, const char *of);char         *first_not_of(char *p, const char *of);char         *first_of(char *p, const char *of);char         *last_not_of(char *p, const char *of);char         *last_of(char *p, const char *of);void          destructive_rtrim(char *p);void          destructive_ltrim(char *p);void          destructive_rtrim(char *p, const char *of);void          destructive_ltrim(char *p, const char *of);void          destructive_trim(char *p);void          destructive_trim(char *p, const char *of);void          destructive_trim(char *p, const char *of_l, const char *of_r);char         *trim(const char *p);char         *trim(const char *p, const char *of);void          trim(std::string &data);void          trim(std::string &data, const char *of);template <typename T>inline bool read_array(const char **s, T *v, int count){    const char *p = *s;    for (int i = 0; i < count; i++)    {        skip_space(&p);        if (!read(&p, v[i]))            return false;    }    *s = p;    return true;}#endif // _STRS_H