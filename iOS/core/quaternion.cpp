/* *  quaternion.cpp *  GLGravity * *  Created by Paul Senzee on 12/30/08. *  Copyright 2008 __MyCompanyName__. All rights reserved. * */#include "quaternion.h"Quaternion &Quaternion::normalize(){     float n = dot(*this);    if (n != 1.0f)    {        n = 1.0f / sqrtf(n);        *this *= n;    }    return *this;}Quaternion Quaternion::operator*(const Quaternion &u) const{    return Quaternion(u.w * x + u.x * w + u.y * z - u.z * y,                      u.w * y + u.y * w + u.z * x - u.x * z,                      u.w * z + u.z * w + u.x * y - u.y * x,                      u.w * w - u.x * x - u.y * y - u.z * z);}Matrix4f Quaternion::matrix() const{    float yy2 = y * y * 2.0f, zz2 = z * z * 2.0f, xx2 = x * x * 2.0f,                xy2 = x * y * 2.0f, zw2 = z * w * 2.0f, xz2 = x * z * 2.0f,          yw2 = y * w * 2.0f, zy2 = z * y * 2.0f, xw2 = x * w * 2.0f;    Matrix4f m;    m.set(1.0f - yy2 - zz2, xy2 + zw2,        xz2 - yw2,        0.0f,          xy2 - zw2,        1.0f - xx2 - zz2, zy2 + xw2,        0.0f,           xz2 + yw2,        zy2 - xw2,        1.0f - xx2 - yy2, 0.0f,          0.0f,             0.0f,             0.0f,             1.0f);    return m;}Quaternion Quaternion::slerp(Quaternion a, Quaternion b, float time){      const float PI = 3.141592653589793f;        float angle = a.dot(b);        if (angle < 0.0f)     {        a     *= -1.0f;        angle *= -1.0f;    }        float scale = 0.0f, invscale = 0.0f;        if ((angle + 1.0f) > 0.05f)     {        // spherical interpolation        if ((1.0f - angle) >= 0.05f)        {            float theta       = acosf(angle),             invsintheta = 1.0f / sinf(theta);            scale    = sinf(theta * (1.0f - time)) * invsintheta;            invscale = sinf(theta * time) * invsintheta;        }        else // linear interploation        {            scale    = 1.0f - time;            invscale = time;        }    }    else     {        b = Quaternion(-a.y, a.x, -a.w, a.z);        scale = sinf(PI * (0.5f - time));        invscale = sinf(PI * time);    }        *this = (a * scale) + (b * invscale);    return *this;}//! The quaternion representing the rotation is //!  q = cos(A / 2) + sin(A / 2) * (x * i + y * j + z * k)Quaternion Quaternion::CreateFromAxisAngle(const Tuple3f &axis, float angle){     float h = 0.5f * angle;    return Quaternion(axis.normal() * sinf(h), cosf(h));    }