#include "simplexml.h"#include "global.h"#include "core_assert.h"#include <exception>#include <string>#include <vector>#include <stdio.h>class XmlParseIterator{public:    int         line,                character;    const char *source,               *current;    bool        end;    enum { NEWLINE_INDICATOR = '\n', NEWLINE_DISCARD = '\r' };    XmlParseIterator(const char *text) : source(text), current(text), line(1), character(1)    {        if (!text) globalErrorHandler("Null text passed to XmlParseIterator\n");        end = !text ? true : !*text;    }    inline char at()    {        return *current;    }    inline void next()    {        char c = *current;        if (!c) { end = true; }        else if (c == NEWLINE_INDICATOR)        {            line++;            character = 1;        }        else if (c == NEWLINE_DISCARD)        {            while (*current == NEWLINE_DISCARD && *current)                current++;            return;        }        current++;    }    void next(int count)    {        for (int i = 0; i < count; i++)            next();    }    inline bool done()    {        return end;    }    void skipSpace()    {tryAgain:        while (isspace(*current))            next();        if (is("<!--"))        {            next(sizeof("<!--") - 1);            while (!done() && !is("-->"))                next();            if (done())            {                globalErrorHandler("Unexpected end of file found in comment (<!-- .. -->)!\n");                return;            }            next(sizeof("-->") - 1);            goto tryAgain;        }    }    inline bool is(const char *id)    {        return strncmp(current, id, strlen(id)) == 0;    }    bool identifier(std::string &id)    {        id.clear();        char c = 0;        bool parsed = false;        while (!done())        {            c = *current;            if (!isalnum(c) && !strchr("-:@_.", c))                break;            id += c;            parsed = true;            next();        }        return parsed;    }    bool quoted(std::string &id, char quote)    {        id.clear();        if (*current != quote)            return false;        next();        char c = 0;        bool parsed = false;        while (!done())        {            c = *current;            if (c == quote)                break;            id += c;            parsed = true;            next();        }        if (*current != quote)        {            globalErrorHandler("Unterminated quoted text.\n");            return false;        }        next();        return true;    }    bool quoted(std::string &id)    {        return quoted(id, '"') || quoted(id, '\'');    }    bool parseOpenTag(std::string &id)    {        skipSpace();        XmlParseIterator i = *this;        if (!i.is("<"))            return false;        i.next();        if (!i.identifier(id))            return false;        *this = i;        return true;    }    bool parseCloseTag(const char *id)    {        enum { END_LENGTH = sizeof("</") - 1 };        skipSpace();        XmlParseIterator i = *this;        if (!i.is("</"))            return false;        i.next(END_LENGTH);        if (!i.is(id))            return false;        i.next((int)strlen(id));        i.skipSpace();        if (!i.is(">"))        {            globalErrorHandler("Closing tag cannot have anything other than identifier.\n");            return false;        }        i.next();        *this = i;        return true;    }    bool parseAttribute(std::string &key, std::string &value)    {        skipSpace();        XmlParseIterator i = *this;        if (!i.identifier(key))            return false;        i.skipSpace();        if (!i.is("="))            return false;        i.next();        i.skipSpace();        if (!i.identifier(value) && !i.quoted(value))            return false;        *this = i;        return true;    }    inline bool parseTagNormalEnd()    {        skipSpace();        if (!is(">")) return false;        next();        return true;    }    inline bool parseTagClosedEnd()    {        skipSpace();        if (!is("/>")) return false;        next(sizeof("/>") - 1);        return true;    }};static const char *cpp_strdup(const char *s){    char *ns = 0;    if (s)    {        size_t sz = strlen(s);        ns = new char [sz + 1];        strcpy(ns, s);    }    return ns;}XmlAttribute::XmlAttribute(const char *key, const char *value) : key(cpp_strdup(key)), value(cpp_strdup(value)){}XmlAttribute::~XmlAttribute(){    if (key)   { delete [] key;   key   = 0; }    if (value) { delete [] value; value = 0; }}XmlElement::XmlElement(Type type, const char *name, const char *text) : type(type), name(cpp_strdup(name)), text(cpp_strdup(text)), attributeCount(0), childrenCount(0), attributes(0), children(0){}XmlElement::~XmlElement(){    if (name)    {        delete [] name;        name = 0;    }    if (text)    {        delete [] text;        text = 0;    }    if (attributes)    {        for (int i = 0; i < attributeCount; i++)            delete attributes[i];        delete [] attributes;        attributes = 0;    }    if (children)    {        for (int i = 0; i < childrenCount; i++)            delete children[i];        delete [] children;        children = 0;    }}static XmlElement *parse(XmlParseIterator &i){    i.skipSpace();    if (i.is("</"))        return 0;    std::string name;    if (!i.parseOpenTag(name))    {        std::string text;        while (i.at() != '<')        {            text += i.at();            i.next();        }        if (!text.empty())            return new XmlElement(XmlElement::TEXT, 0, text.c_str());        return 0;    }    XmlElement *e = new XmlElement(XmlElement::TAG, name.c_str());    std::string key, value;    std::vector<XmlAttribute *> attributes;    while (i.parseAttribute(key, value))        attributes.push_back(new XmlAttribute(key.c_str(), value.c_str()));    size_t sz = attributes.size();    if (sz)    {        e->attributes = new XmlAttribute * [sz];        for (size_t i = 0; i < sz; i++)        {            e->attributes[i] = attributes[i];            core_assert(attributes[i]);        }        e->attributeCount = (int)sz;    }    if (i.parseTagClosedEnd())        return e;    if (!i.parseTagNormalEnd())    {        delete e;        globalErrorHandler("Expected tag end in XML file - can't read!\n");        return 0;    }    XmlElement *child = 0;    std::vector<XmlElement *> children;    do    {        XmlParseIterator ci = i;        child = parse(ci);        if (child)        {            i = ci;            children.push_back(child);        }    } while (child != 0);    sz = children.size();    if (sz)    {        e->children = new XmlElement * [sz];        for (size_t i = 0; i < sz; i++)        {            e->children[i] = children[i];            core_assert(children[i]);        }        e->childrenCount = (int)sz;    }    if (!i.parseCloseTag(e->name))    {        delete e;        globalErrorHandler("Expected closing tag in XML file - can't read!\n");        return 0;    }    return e;}static void indent(int count){    for (int i = 0; i < count; i++)        printf(" ");}static void printAttributes(XmlElement *elem, int depth){    if (elem && elem->attributeCount)    {        indent(depth);        for (int i = 0; i < elem->attributeCount; i++)            printf("%s='%s' ", elem->attributes[i]->key, elem->attributes[i]->value);        printf("\n");    }}static void print(XmlElement *elem, int depth){    if (elem)    {        if (elem->type == XmlElement::TEXT)        {            indent(depth);            printf("TEXT: '%s'\n", elem->text);        }        else        {            indent(depth);            printf("%s\n", elem->name);            printAttributes(elem, depth);            indent(depth);            printf("{\n");            for (int i = 0; i < elem->childrenCount; i++)                print(elem->children[i], depth + 1);            indent(depth);            printf("}\n");        }    }}void print(XmlElement *elem){    print(elem, 0);}XmlElement *parse(const char *text){    core_assert(text && "text must not be null!");    if (!text) return 0;    XmlParseIterator i(text);    return parse(i);}int findElementIndex(XmlElement *xml, const char *name, int start){    for (int i = start, sz = xml->childrenCount; i < sz; i++)        if (strcmp(xml->children[i]->name, name) == 0)            return i;    return -1;}int findAttributeIndex(XmlElement *xml, const char *key, int start){    if (xml)        for (int i = start, sz = xml->attributeCount; i < sz; i++)            if (strcmp(xml->attributes[i]->key, key) == 0)                return i;    return -1;}bool hasKeyValueEqualTo(XmlElement *xml, const char *key, const char *value, int start){    int kid = findAttributeIndex(xml, key, start);    return kid != -1 && strcmp(xml->attributes[kid]->value, value) == 0;}int findElementIndexWithKeyValue(XmlElement *xml, const char *name, const char *key, const char *value, int start){    int eid = 0;    while ((eid = findElementIndex(xml, name, eid)) != -1)    {        if (hasKeyValueEqualTo(xml->children[eid], key, value))            return eid;        eid++;    }    return -1;}XmlElement *elementAt(XmlElement *xml, int index){    if (!xml || index < 0 || index >= xml->childrenCount)        return 0;    return xml->children[index];}XmlAttribute *attributeAt(XmlElement *xml, int index){    if (!xml || index < 0 || index >= xml->attributeCount)        return 0;    return xml->attributes[index];}bool validate(XmlElement *e) // just validate that we don't have any null pointers here{    if (!e)        return false;    for (int i = 0; i < e->attributeCount; i++)        if (!e->attributes[i] || !e->attributes[i]->key || !e->attributes[i]->value)            return false;    for (int i = 0; i < e->childrenCount; i++)        if (!validate(e->children[i]))            return false;    return true;}