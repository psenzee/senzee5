#ifndef _MATRIX4F_H#define _MATRIX4F_H#include "mathcore.h"#include "tuple3f.h"#include "tuple4f.h"#include "matrix_operations.h"#include <math.h>#include <string.h>#include <vector>#define APPLE_OPTIMIZE 0extern "C" double cos(double);extern "C" double sin(double);class Matrix4f{public:    typedef Matrix4f self;    typedef Tuple3f  vec3_t;    typedef Tuple4f  vec4_t;    float data[16];    inline Matrix4f()                                      { identity(); }    inline Matrix4f(const self &m)                         { memcpy((float *)data, (const float *)m.data, sizeof(data)); }    inline Matrix4f(const float *m)                        { memcpy((float *)data, m, sizeof(data)); }        inline self     operator*(float p)               const { self r(*this); r *= p; return r; }    inline self     operator/(float p)               const { self r(*this); r /= p; return r; }    inline self     operator*(const self &p)         const { self r(*this); r *= p; return r; }    inline vec3_t   operator*(const vec3_t &p)       const { return point(p); }    inline vec4_t   operator*(const vec4_t &p)       const { return transform(p); }    inline self    &operator*=(float s)                    { scale(s);        return *this; }    inline self    &operator/=(float s)                    { scale(1.0f / s); return *this; }    inline self    &operator*=(const self &m)              { self r(*this); m_mmatrix4((float *)data, (const float *)r.data, (const float *)m.data); return *this; }    inline bool     operator==(const self &m)        const { return memcmp(m.data, data, sizeof(self)) == 0; }    inline bool     approxeq(const self &m)          const { bool f = false; for (int i = 0; i < 16 && !f; i++) f = math::eq(m.data[i], data[i]); return !f; }            inline bool     operator!=(const self &m)        const { return !operator==(m); }    inline float   &operator()(size_t i, size_t j)         { return data[(j << 2) + i]; }    inline const float &operator()(size_t i, size_t j)   const { return data[(j << 2) + i]; }        inline self                 invert(bool transpose = false)      const { self m; invert4x4(data, m.data, transpose); return m; }    inline vec4_t               transform(const vec4_t &v)          const { vec4_t r; m_mvector4x4((float *)&r, (const float *)data, (const float *)&v); return r; }    inline vec4_t               transformtranspose(const vec4_t &v) const { vec4_t r; m_mvector4x4transpose((float *)&r, (const float *)data, (const float *)&v); return r; }    inline vec3_t               point (const vec3_t &p)             const { vec3_t r; m_mvector4x3w1((float *)&r, (const float *)data, (const float *)&p); return r; }    inline vec3_t               vector(const vec3_t &p)             const { vec3_t r; m_mvector4x3w0((float *)&r, (const float *)data, (const float *)&p); return r; }    inline vec3_t               pointtranspose(const vec3_t &p)     const { vec3_t r; m_mvector4x3w1transpose((float *)&r, (const float *)data, (const float *)&p); return r; }    inline vec3_t               vectortranspose(const vec3_t &p)    const { vec3_t r; m_mvector4x3w0transpose((float *)&r, (const float *)data, (const float *)&p); return r; }    inline void    identity()    {        static const float idn[16] = {  1, 0, 0, 0,                                        0, 1, 0, 0,                                        0, 0, 1, 0,                                        0, 0, 0, 1  };        memcpy(data, idn, sizeof(idn));    }    inline void    set(float a, float b, float c, float d,                       float e, float f, float g, float h,                       float i, float j, float k, float l,                       float m, float n, float o, float p);    inline void    scale(float s);    inline void    scale(const vec3_t &s);    inline void    scale(const vec3_t &s, const vec3_t &origin);    inline void    translate(const vec3_t &p);    inline void    rotation(const vec3_t &s, const vec3_t &t);    inline void    rotationx(float theta, bool rh = false);    inline void    rotationy(float theta, bool rh = false);    inline void    rotationz(float theta, bool rh = false);    inline void    eulerrotation(const vec3_t &p, bool rh = false) { eulerrotation(p.y, p.x, p.z, rh); }    inline void    eulerrotation(float yaw, float pitch, float roll, bool rh = false);    inline void    rotationaxis(const vec3_t &p, float theta, bool rh = false);    inline void    reoriginate(const vec3_t &origin);    inline void    transpose();    inline void    diagonal(vec3_t &v) const;    inline void    diagonal(vec4_t &v) const;    inline vec3_t &gettranslation(vec3_t &p);    inline self   &settranslation(const vec3_t &p);    inline void    lookat(const vec3_t &eye, const vec3_t &up, const vec3_t &at);    inline void    fov(float fov, float aspectratio, float znear, float zfar, bool rh = false);    inline void    perspective(float viewvolwidth, float viewvolheight, float znear, float zfar, bool rh = false);    inline void    orthogonal(float viewvolwidth, float viewvolheight, float znear, float zfar, bool rh = false);    inline void    fliprows();    inline void    flipcols();    inline void    clear();private:    inline static void m_rotx(float *m, float cos_t, float sin_t);    inline static void m_roty(float *m, float cos_t, float sin_t);    inline static void m_rotz(float *m, float cos_t, float sin_t);    inline static void m_rotaxis(float *m, float x, float y, float z, float cos_t, float sin_t);    inline static void m_scale(float *m, float a, float b, float c, float d);    inline static void m_translate(float *m, float a, float b, float c);    inline static void m_identity(float *m);    inline static void m_mvector4x4(float *v, const float *m, const float *u);    inline static void m_mvector4x4transpose(float *v, const float *m, const float *u);    inline static void m_mvector4x3wn(float *v, const float *m, const float *u, float w);    inline static void m_mvector4x3w1(float *v, const float *m, const float *u);    inline static void m_mvector4x3w0(float *v, const float *m, const float *u);    inline static void m_mvector4x3wntranspose(float *v, const float *m, const float *u, float w);    inline static void m_mvector4x3w1transpose(float *v, const float *m, const float *u);    inline static void m_mvector4x3w0transpose(float *v, const float *m, const float *u);    inline static void m_mmatrix3transpose(float *m, const float *a, const float *b);    inline static void m_mmatrix4(float *m, const float *a, const float *b);    inline static void m_mmatrix4transpose(float *m, const float *a, const float *b);};inline Tuple3f &operator*=(Tuple3f &p, const Matrix4f &m){     return p = m.point(p);}inline void Matrix4f::lookat(const Tuple3f &eye, const Tuple3f &up, const Tuple3f &at){    Tuple3f zaxis = (at - eye).normalize(),            xaxis = up.cross(zaxis).normalize(),            yaxis = zaxis.cross(xaxis);    set(         xaxis.x,          yaxis.x,          zaxis.x, 0,                 xaxis.y,          yaxis.y,          zaxis.y, 0,                 xaxis.z,          yaxis.z,          zaxis.z, 0,         -xaxis.dot(eye),  -yaxis.dot(eye),  -zaxis.dot(eye), 1);}inline void Matrix4f::translate(const vec3_t &p){    m_translate((float *)data, p.x, p.y, p.z);}inline void Matrix4f::scale(const vec3_t &p){    m_scale((float *)data, p.x, p.y, p.z, 1);}inline void Matrix4f::scale(float s){    m_scale((float *)data, s, s, s, 1);}inline void Matrix4f::rotation(const vec3_t &s, const vec3_t &t){    if (s == t)    {        identity();        return;    }    vec3_t cr(s.cross(t));    float e = s.dot(t), f = 1.0f - e, g = cr.length();    vec3_t u(cr / g);    /*    rotate vec s to vec t    where e == cos(2 * theta) == s.dot(t)            &&          f == 1 - e                                 &&          g == sin(2 * theta) == s.cross(t).length() &&          u == s.cross(t).normal();    e + f * u.x * u.x         f * u.x * u.y - g * u.z    f * u.x * u.z + g * u.y    0    f * u.x * u.y + g * u.z   e + f * u.y * u.y          f * u.y * u.z - g * u.x    0    f * u.x * u.z - g * u.y   f * u.y * u.z + g * u.x    e + f * u.z * u.z          0    0                         0                          0                          1    transposed:    */    set(e + f * u.x * u.x,        f * u.x * u.y + g * u.z,    f * u.x * u.z - g * u.y,    0,        f * u.x * u.y - g * u.z,  e + f * u.y * u.y,          f * u.y * u.z + g * u.x,    0,        f * u.x * u.z + g * u.y,  f * u.y * u.z - g * u.x,    e + f * u.z * u.z,          0,        0,                        0,                          0,                          1);}inline void Matrix4f::set(float a, float b, float c, float d,                          float e, float f, float g, float h,                          float i, float j, float k, float l,                          float m, float n, float o, float p){    float *x = (float *)data;    *(x + 0)  = a; *(x + 1)  = b; *(x + 2)  = c;  *(x + 3)  = d;    *(x + 4)  = e; *(x + 5)  = f; *(x + 6)  = g;  *(x + 7)  = h;    *(x + 8)  = i; *(x + 9)  = j; *(x + 10) = k;  *(x + 11) = l;    *(x + 12) = m; *(x + 13) = n; *(x + 14) = o;  *(x + 15) = p;}inline void Matrix4f::rotationx(float theta, bool rh){    m_rotx((float *)data, cosf(theta), rh ? -sinf(theta) : sinf(theta));}inline void Matrix4f::rotationy(float theta, bool rh){    m_roty((float *)data, cosf(theta), rh ? -sinf(theta) : sinf(theta));}inline void Matrix4f::rotationz(float theta, bool rh){    m_rotz((float *)data, cosf(theta), rh ? -sinf(theta) : sinf(theta));}inline void Matrix4f::rotationaxis(const vec3_t &p, float theta, bool rh){    m_rotaxis((float *)data, p.x, p.y, p.z, cosf(theta), rh ? -sinf(theta) : sinf(theta));}inline void Matrix4f::eulerrotation(float yaw, float pitch, float roll, bool rh){    Matrix4f t;      rotationz(roll,  rh);    t.rotationx(pitch, rh); *this *= t;    t.rotationy(yaw,   rh); *this *= t;}// private implementation..inline void Matrix4f::m_rotx(float *m, float cos_t, float sin_t){    *(m + 0)  =   1.0f; *(m + 1)  =  0.0f;  *(m + 2)  =  0.0f;   *(m + 3)  = 0.0f;    *(m + 4)  =   0.0f; *(m + 5)  =  cos_t; *(m + 6)  = -sin_t;  *(m + 7)  = 0.0f;    *(m + 8)  =   0.0f; *(m + 9)  =  sin_t; *(m + 10) =  cos_t;  *(m + 11) = 0.0f;    *(m + 12) =   0.0f; *(m + 13) =  0.0f;  *(m + 14) =  0.0f;   *(m + 15) = 1.0f;}inline void Matrix4f::m_roty(float *m, float cos_t, float sin_t){    *(m + 0)  =  cos_t; *(m + 1)  =  0.0f;  *(m + 2)  =  sin_t;  *(m + 3)  = 0.0f;    *(m + 4)  =  0.0f;  *(m + 5)  =  1.0f;  *(m + 6)  =  0.0f;   *(m + 7)  = 0.0f;    *(m + 8)  = -sin_t; *(m + 9)  =  0.0f;  *(m + 10) =  cos_t;  *(m + 11) = 0.0f;    *(m + 12) =  0.0f;  *(m + 13) =  0.0f;  *(m + 14) =  0.0f;   *(m + 15) = 1.0f;}inline void Matrix4f::m_rotz(float *m, float cos_t, float sin_t){    *(m + 0)  =  cos_t; *(m + 1)  = -sin_t; *(m + 2)  =  0.0f;   *(m + 3)  = 0.0f;    *(m + 4)  =  sin_t; *(m + 5)  =  cos_t; *(m + 6)  =  0.0f;   *(m + 7)  = 0.0f;    *(m + 8)  =  0.0f;  *(m + 9)  =  0.0f;  *(m + 10) =  1.0f;   *(m + 11) = 0.0f;    *(m + 12) =  0.0f;  *(m + 13) =  0.0f;  *(m + 14) =  0.0f;   *(m + 15) = 1.0f;}inline void Matrix4f::m_rotaxis(float *m, float x, float y, float z, float cos_t, float sin_t){    float t   = 1.0f - cos_t,          sx  = sin_t * x, sy  = sin_t * y, sz  = sin_t * z,          tx  = t     * x, ty  = t     * y, tz  = t     * z,          txx = tx    * x, txy = tx    * y, tyy = ty    * y,          tyz = ty    * z, tzz = tz    * z, txz = tx    * z;    *(m + 0)  = txx + cos_t; *(m + 1)  =  txy - sz;    *(m + 2)  = txz + sy;    *(m + 3)  = 0.0f;    *(m + 4)  = txy + sz;    *(m + 5)  =  tyy + cos_t; *(m + 6)  = tyz - sx;    *(m + 7)  = 0.0f;    *(m + 8)  = txz - sy;    *(m + 9)  =  tyz + sx;    *(m + 10) = tzz + cos_t; *(m + 11) = 0.0f;    *(m + 12) = 0.0f;        *(m + 13) =  0.0f;        *(m + 14) = 0.0f;        *(m + 15) = 1.0f;}inline void Matrix4f::m_scale(float *m, float a, float b, float c, float d){    *(m + 0)  =  a;     *(m + 1)  =  0.0f;  *(m + 2)  =  0.0f;   *(m + 3)  = 0.0f;    *(m + 4)  =  0.0f;  *(m + 5)  =  b;     *(m + 6)  =  0.0f;   *(m + 7)  = 0.0f;    *(m + 8)  =  0.0f;  *(m + 9)  =  0.0f;  *(m + 10) =  c;      *(m + 11) = 0.0f;    *(m + 12) =  0.0f;  *(m + 13) =  0.0f;  *(m + 14) =  0.0f;   *(m + 15) = d;}inline void Matrix4f::m_translate(float *m, float a, float b, float c){    *(m + 0)  =  1.0f;  *(m + 1)  =  0.0f;  *(m + 2)  =  0.0f;   *(m + 3)  = 0;    *(m + 4)  =  0.0f;  *(m + 5)  =  1.0f;  *(m + 6)  =  0.0f;   *(m + 7)  = 0;    *(m + 8)  =  0.0f;  *(m + 9)  =  0.0f;  *(m + 10) =  1.0f;   *(m + 11) = 0;    *(m + 12) =     a;  *(m + 13) =     b;  *(m + 14) =     c;   *(m + 15) = 1.0f;}inline void Matrix4f::m_mvector4x4(float *v, const float *m, const float *u){    *(v + 0) = *(m + 0) * *(u + 0) + *(m + 4) * *(u + 1) + *(m + 8)  * *(u + 2) + *(m + 12) * *(u + 3);    *(v + 1) = *(m + 1) * *(u + 0) + *(m + 5) * *(u + 1) + *(m + 9)  * *(u + 2) + *(m + 13) * *(u + 3);    *(v + 2) = *(m + 2) * *(u + 0) + *(m + 6) * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 14) * *(u + 3);    *(v + 3) = *(m + 3) * *(u + 0) + *(m + 7) * *(u + 1) + *(m + 11) * *(u + 2) + *(m + 15) * *(u + 3);}inline void Matrix4f::m_mvector4x4transpose(float *v, const float *m, const float *u){    *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 1)  * *(u + 1) + *(m + 2)  * *(u + 2) + *(m + 3)  * *(u + 3);    *(v + 1) = *(m + 4)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 6)  * *(u + 2) + *(m + 7)  * *(u + 3);    *(v + 2) = *(m + 8)  * *(u + 0) + *(m + 9)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 11) * *(u + 3);    *(v + 3) = *(m + 12) * *(u + 0) + *(m + 13) * *(u + 1) + *(m + 14) * *(u + 2) + *(m + 15) * *(u + 3);}inline void Matrix4f::m_mvector4x3wn(float *v, const float *m, const float *u, float w){    *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 4)  * *(u + 1) + *(m + 8)  * *(u + 2) + *(m + 12) * w;    *(v + 1) = *(m + 1)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 9)  * *(u + 2) + *(m + 13) * w;    *(v + 2) = *(m + 2)  * *(u + 0) + *(m + 6)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 14) * w;}inline void Matrix4f::m_mvector4x3w1(float *v, const float *m, const float *u){    *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 4)  * *(u + 1) + *(m + 8)  * *(u + 2) + *(m + 12);    *(v + 1) = *(m + 1)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 9)  * *(u + 2) + *(m + 13);    *(v + 2) = *(m + 2)  * *(u + 0) + *(m + 6)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 14);}inline void Matrix4f::m_mvector4x3w0(float *v, const float *m, const float *u){    *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 4) * *(u + 1) + *(m + 8)  * *(u + 2);    *(v + 1) = *(m + 1)  * *(u + 0) + *(m + 5) * *(u + 1) + *(m + 9)  * *(u + 2);    *(v + 2) = *(m + 2)  * *(u + 0) + *(m + 6) * *(u + 1) + *(m + 10) * *(u + 2);}inline void Matrix4f::m_mvector4x3w1transpose(float *v, const float *m, const float *u){    *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 1)  * *(u + 1) + *(m + 2)  * *(u + 2) + *(m + 3);    *(v + 1) = *(m + 4)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 6)  * *(u + 2) + *(m + 7);    *(v + 2) = *(m + 8)  * *(u + 0) + *(m + 9)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 11);}inline void Matrix4f::m_mvector4x3wntranspose(float *v, const float *m, const float *u, float w){    *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 1)  * *(u + 1) + *(m + 2)  * *(u + 2) + *(m + 3) * w;    *(v + 1) = *(m + 4)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 6)  * *(u + 2) + *(m + 7) * w;    *(v + 2) = *(m + 8)  * *(u + 0) + *(m + 9)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 11) * w;}inline void Matrix4f::m_mvector4x3w0transpose(float *v, const float *m, const float *u){    *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 1) * *(u + 1) + *(m + 2)  * *(u + 2);    *(v + 1) = *(m + 4)  * *(u + 0) + *(m + 5) * *(u + 1) + *(m + 6)  * *(u + 2);    *(v + 2) = *(m + 8)  * *(u + 0) + *(m + 9) * *(u + 1) + *(m + 10) * *(u + 2);}inline void Matrix4f::m_mmatrix4transpose(float *m, const float *b, const float *a){    *(m + 0)  = *(b + 0)  * *(a + 0) + *(b + 1)  * *(a + 4) + *(b + 2)  * *(a + 8)  + *(b + 3)  * *(a + 12);    *(m + 4)  = *(b + 0)  * *(a + 1) + *(b + 1)  * *(a + 5) + *(b + 2)  * *(a + 9)  + *(b + 3)  * *(a + 13);    *(m + 8)  = *(b + 0)  * *(a + 2) + *(b + 1)  * *(a + 6) + *(b + 2)  * *(a + 10) + *(b + 3)  * *(a + 14);    *(m + 12) = *(b + 0)  * *(a + 3) + *(b + 1)  * *(a + 7) + *(b + 2)  * *(a + 11) + *(b + 3)  * *(a + 15);    *(m + 1)  = *(b + 4)  * *(a + 0) + *(b + 5)  * *(a + 4) + *(b + 6)  * *(a + 8)  + *(b + 7)  * *(a + 12);    *(m + 5)  = *(b + 4)  * *(a + 1) + *(b + 5)  * *(a + 5) + *(b + 6)  * *(a + 9)  + *(b + 7)  * *(a + 13);    *(m + 9)  = *(b + 4)  * *(a + 2) + *(b + 5)  * *(a + 6) + *(b + 6)  * *(a + 10) + *(b + 7)  * *(a + 14);    *(m + 13) = *(b + 4)  * *(a + 3) + *(b + 5)  * *(a + 7) + *(b + 6)  * *(a + 11) + *(b + 7)  * *(a + 15);    *(m + 2)  = *(b + 8)  * *(a + 0) + *(b + 9)  * *(a + 4) + *(b + 10) * *(a + 8)  + *(b + 11) * *(a + 12);    *(m + 6)  = *(b + 8)  * *(a + 1) + *(b + 9)  * *(a + 5) + *(b + 10) * *(a + 9)  + *(b + 11) * *(a + 13);    *(m + 10) = *(b + 8)  * *(a + 2) + *(b + 9)  * *(a + 6) + *(b + 10) * *(a + 10) + *(b + 11) * *(a + 14);    *(m + 14) = *(b + 8)  * *(a + 3) + *(b + 9)  * *(a + 7) + *(b + 10) * *(a + 11) + *(b + 11) * *(a + 15);    *(m + 3)  = *(b + 12) * *(a + 0) + *(b + 13) * *(a + 4) + *(b + 14) * *(a + 8)  + *(b + 15) * *(a + 12);    *(m + 7)  = *(b + 12) * *(a + 1) + *(b + 13) * *(a + 5) + *(b + 14) * *(a + 9)  + *(b + 15) * *(a + 13);    *(m + 11) = *(b + 12) * *(a + 2) + *(b + 13) * *(a + 6) + *(b + 14) * *(a + 10) + *(b + 15) * *(a + 14);    *(m + 15) = *(b + 12) * *(a + 3) + *(b + 13) * *(a + 7) + *(b + 14) * *(a + 11) + *(b + 15) * *(a + 15);}#if defined(__APPLE__) && APPLE_OPTIMIZE != 0#include "math/vfpmath/matrix_impl_rm.h"#endifinline void Matrix4f::m_mmatrix4(float *m, const float *a, const float *b){#if defined(__APPLE__) && APPLE_OPTIMIZE != 0	Matrix4Mul(a, b, m);#else    *(m + 0)  = *(a + 0)  * *(b + 0) + *(a + 1)  * *(b + 4) + *(a + 2)  * *(b + 8)  + *(a + 3)  * *(b + 12);    *(m + 1)  = *(a + 0)  * *(b + 1) + *(a + 1)  * *(b + 5) + *(a + 2)  * *(b + 9)  + *(a + 3)  * *(b + 13);    *(m + 2)  = *(a + 0)  * *(b + 2) + *(a + 1)  * *(b + 6) + *(a + 2)  * *(b + 10) + *(a + 3)  * *(b + 14);    *(m + 3)  = *(a + 0)  * *(b + 3) + *(a + 1)  * *(b + 7) + *(a + 2)  * *(b + 11) + *(a + 3)  * *(b + 15);    *(m + 4)  = *(a + 4)  * *(b + 0) + *(a + 5)  * *(b + 4) + *(a + 6)  * *(b + 8)  + *(a + 7)  * *(b + 12);    *(m + 5)  = *(a + 4)  * *(b + 1) + *(a + 5)  * *(b + 5) + *(a + 6)  * *(b + 9)  + *(a + 7)  * *(b + 13);    *(m + 6)  = *(a + 4)  * *(b + 2) + *(a + 5)  * *(b + 6) + *(a + 6)  * *(b + 10) + *(a + 7)  * *(b + 14);    *(m + 7)  = *(a + 4)  * *(b + 3) + *(a + 5)  * *(b + 7) + *(a + 6)  * *(b + 11) + *(a + 7)  * *(b + 15);    *(m + 8)  = *(a + 8)  * *(b + 0) + *(a + 9)  * *(b + 4) + *(a + 10) * *(b + 8)  + *(a + 11) * *(b + 12);    *(m + 9)  = *(a + 8)  * *(b + 1) + *(a + 9)  * *(b + 5) + *(a + 10) * *(b + 9)  + *(a + 11) * *(b + 13);    *(m + 10) = *(a + 8)  * *(b + 2) + *(a + 9)  * *(b + 6) + *(a + 10) * *(b + 10) + *(a + 11) * *(b + 14);    *(m + 11) = *(a + 8)  * *(b + 3) + *(a + 9)  * *(b + 7) + *(a + 10) * *(b + 11) + *(a + 11) * *(b + 15);    *(m + 12) = *(a + 12) * *(b + 0) + *(a + 13) * *(b + 4) + *(a + 14) * *(b + 8)  + *(a + 15) * *(b + 12);    *(m + 13) = *(a + 12) * *(b + 1) + *(a + 13) * *(b + 5) + *(a + 14) * *(b + 9)  + *(a + 15) * *(b + 13);    *(m + 14) = *(a + 12) * *(b + 2) + *(a + 13) * *(b + 6) + *(a + 14) * *(b + 10) + *(a + 15) * *(b + 14);    *(m + 15) = *(a + 12) * *(b + 3) + *(a + 13) * *(b + 7) + *(a + 14) * *(b + 11) + *(a + 15) * *(b + 15);#endif	}inline void Matrix4f::transpose(){    float d[16];    d[0] = data[0];  d[4] = data[1];  d[8]  = data[2];  d[12] = data[3];    d[1] = data[4];  d[5] = data[5];  d[9]  = data[6];  d[13] = data[7];    d[2] = data[8];  d[6] = data[9];  d[10] = data[10]; d[14] = data[11];    d[3] = data[12]; d[7] = data[13]; d[11] = data[14]; d[15] = data[15];    memcpy((float *)data, (const float *)d, sizeof(d));}inline void Matrix4f::diagonal(vec3_t &v) const{    v.set(data[0], data[5], data[10]);}inline void Matrix4f::diagonal(vec4_t &v) const{    v.set(data[0], data[5], data[10], data[15]);}inline void Matrix4f::flipcols(){    float d[16];    d[0] = data[12]; d[4] = data[8];  d[8]  = data[4]; d[12] = data[0];    d[1] = data[13]; d[5] = data[9];  d[9]  = data[5]; d[13] = data[1];    d[2] = data[14]; d[6] = data[10]; d[10] = data[6]; d[14] = data[2];    d[3] = data[15]; d[7] = data[11]; d[11] = data[7]; d[15] = data[3];    memcpy((float *)data, (const float *)d, sizeof(d));}inline void Matrix4f::fliprows(void){    float d[16];    d[0] = data[3]; d[4] = data[7]; d[8]  = data[11]; d[12] = data[15];    d[1] = data[2]; d[5] = data[6]; d[9]  = data[10]; d[13] = data[14];    d[2] = data[1]; d[6] = data[5]; d[10] = data[9];  d[14] = data[13];    d[3] = data[0]; d[7] = data[4]; d[11] = data[8];  d[15] = data[12];    memcpy((float *)data, (const float *)d, sizeof(d));}inline void Matrix4f::clear(){    memset(data, 0, sizeof(float) * 4 * 4);}inline void Matrix4f::fov(float fov, float aspectratio, float znear, float zfar, bool rh){    float h = cosf(fov * 0.5f) / sinf(fov * 0.5f);    perspective(h / aspectratio, h, znear, zfar, rh);}inline void Matrix4f::orthogonal(float w, float h, float znear, float zfar, bool rh){    float zd = znear - zfar;    set(2 / w, 0,     0,          0,        0,     2 / h, 0,          0,        0,     0,     1 / zd,     0,        0,     0,     znear / zd, rh ? -1.0f : 1.0f);}inline void Matrix4f::perspective(float w, float h, float znear, float zfar, bool rh){    float zvol = zfar / (zfar - znear);    set(w,  0,   0,            0,        0,  h,   0,            0,        0,  0,   zvol,         rh ? -1.0f : 1.0f,        0,  0,  -znear * zvol, 0);}#endif  // _MATRIX4F_H 