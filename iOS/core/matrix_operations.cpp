#include "matrix_operations.h"#include <string.h>#include <math.h>double det4x4(double a, double b, double c, double d,              double e, double f, double g, double h,              double i, double j, double k, double l,              double m, double n, double o, double p){    return  a * (f * (k * p - l * o) + g * (l * n - j * p) + h * (j * o - k * n))    - b * (g * (l * m - i * p) + h * (i * o - k * m) + e * (k * p - l * o))    + c * (h * (i * n - j * m) + e * (j * p - l * n) + f * (l * m - i * p))    - d * (e * (j * o - k * n) + f * (k * m - i * o) + g * (i * n - j * m));}static void _copy3x3to4x4(double a, double b, double c,                          double d, double e, double f,                          double g, double h, double i, double *m){    m[ 0] = a;  m[ 1] = b;  m[ 2] = c;  m[ 3] = 0.;    m[ 4] = d;  m[ 5] = e;  m[ 6] = f;  m[ 7] = 0.;    m[ 8] = g;  m[ 9] = h;  m[10] = i;  m[11] = 0.;    m[12] = 0.; m[13] = 0.; m[14] = 0.; m[15] = 1.;}static void _copy3x3to4x4(const double *ma, double *mb){    mb[ 0] = ma[0]; mb[ 1] = ma[1]; mb[ 2] = ma[2]; mb[ 3] = 0.;    mb[ 4] = ma[3]; mb[ 5] = ma[4]; mb[ 6] = ma[5]; mb[ 7] = 0.;    mb[ 8] = ma[6]; mb[ 9] = ma[7]; mb[10] = ma[8]; mb[11] = 0.;    mb[12] =    0.; mb[13] =    0.; mb[14] =    0.; mb[15] = 1.;}static void _copy4x4(double a, double b, double c, double d,                     double e, double f, double g, double h,                     double i, double j, double k, double l,                     double m, double n, double o, double p,                                          double *mb, bool transpose){    if (transpose)    {        mb[ 0] = a; mb[ 4] = b; mb[ 8] = c; mb[12] = d;        mb[ 1] = e; mb[ 5] = f; mb[ 9] = g; mb[13] = h;        mb[ 2] = i; mb[ 6] = j; mb[10] = k; mb[14] = l;        mb[ 3] = m; mb[ 7] = n; mb[11] = o; mb[15] = p;    }    else    {        mb[ 0] = a; mb[ 1] = b; mb[ 2] = c; mb[ 3] = d;        mb[ 4] = e; mb[ 5] = f; mb[ 6] = g; mb[ 7] = h;        mb[ 8] = i; mb[ 9] = j; mb[10] = k; mb[11] = l;        mb[12] = m; mb[13] = n; mb[14] = o; mb[15] = p;    }}static void _copy3x3(double a, double b, double c,                     double d, double e, double f,                     double g, double h, double i,                                          double *mb, bool transpose){    if (transpose)    {        mb[0] = a; mb[3] = b; mb[6] = c;        mb[1] = d; mb[4] = e; mb[7] = f;        mb[2] = g; mb[5] = h; mb[8] = i;    }    else    {        mb[0] = a; mb[1] = b; mb[2] = c;        mb[3] = d; mb[4] = e; mb[5] = f;        mb[6] = g; mb[7] = h; mb[8] = i;    }}static bool _invert3x3(double a, double b, double c,                       double d, double e, double f,                       double g, double h, double i, double *mb, bool transpose) // $TODO test this{    double di = det3x3(a, b, c,  d, e, f,  g, h, i);    if (di == 0.)        return false; // not invertible..    di = 1. / di;    double _a =  det2x2(e, f, h, i) * di, _b = -det2x2(d, f, g, i) * di, _c =  det2x2(d, e, g, h) * di,    _d = -det2x2(b, c, h, i) * di, _e =  det2x2(a, c, g, i) * di, _f = -det2x2(a, b, g, h) * di,    _g =  det2x2(b, c, e, f) * di, _h = -det2x2(a, c, d, f) * di, _i =  det2x2(a, b, d, e) * di;    _copy3x3(_a, _b, _c,  _d, _e, _f,  _g, _h, _i, mb, transpose ^ true); // transpose has to be the opposite here..    return true;}bool invert3x3(const double *ma, double *mb, bool transpose){    double a = ma[0], b = ma[1], c = ma[2],    d = ma[3], e = ma[4], f = ma[5],    g = ma[6], h = ma[7], i = ma[8];    return _invert3x3(a, b, c,                      d, e, f,                      g, h, i, mb, transpose);}bool invert4x4(const double *ma, double *mb, bool transpose){    double a = ma[ 0], b = ma[ 1], c = ma[ 2], d = ma[ 3],    e = ma[ 4], f = ma[ 5], g = ma[ 6], h = ma[ 7],    i = ma[ 8], j = ma[ 9], k = ma[10], l = ma[11],    m = ma[12], n = ma[13], o = ma[14], p = ma[15];    if (m == 0. && n == 0. && o == 0. && d == 0. && h == 0. && l == 0. && p == 1.) // special case for sub 3x3..    {        double x[9];        if (!_invert3x3(a, b, c,                        e, f, g,                        i, j, k, x, transpose))            return false; // not invertible..        _copy3x3to4x4(x, mb);        return true;    }    double di = det4x4(a, b, c, d,                       e, f, g, h,                       i, j, k, l,                       m, n, o, p);    if (di == 0.)        return false; // not invertible..    di = 1. / di;    double _a =  det3x3(f, g, h, j, k, l, n, o, p) * di,    _b = -det3x3(e, g, h, i, k, l, m, o, p) * di,    _c =  det3x3(e, f, h, i, j, l, m, n, p) * di,    _d = -det3x3(e, f, g, i, j, k, m, n, o) * di,    _e = -det3x3(b, c, d, j, k, l, n, o, p) * di,    _f =  det3x3(a, c, d, i, k, l, m, o, p) * di,    _g = -det3x3(a, b, d, i, j, l, m, n, p) * di,    _h =  det3x3(a, b, c, i, j, k, m, n, o) * di,    _i =  det3x3(b, c, d, f, g, h, n, o, p) * di,    _j = -det3x3(a, c, d, e, g, h, m, o, p) * di,    _k =  det3x3(a, b, d, e, f, h, m, n, p) * di,    _l = -det3x3(a, b, c, e, f, g, m, n, o) * di,    _m = -det3x3(b, c, d, f, g, h, j, k, l) * di,    _n =  det3x3(a, c, d, e, g, h, i, k, l) * di,    _o = -det3x3(a, b, d, e, f, h, i, j, l) * di,    _p =  det3x3(a, b, c, e, f, g, i, j, k) * di;    _copy4x4(_a, _b, _c, _d,              _e, _f, _g, _h,             _i, _j, _k, _l,             _m, _n, _o, _p, mb, transpose ^ true); // transpose has to be the opposite here..    return true;}void floats_to_doubles(const float *mf, double *md, unsigned count){    for (unsigned i = 0; i < count; i++) md[i] = (double)mf[i];}void doubles_to_floats(const double *md, float *mf, unsigned count){    for (unsigned i = 0; i < count; i++) mf[i] = (float)md[i];}bool invert_projection4x4(const double *m, double *n){    double a = m[ 0], b = m[ 5], c = m[ 2], d = m[ 6],    e = m[10], f = m[11];    if (a == 0. || b == 0. || f == 0.)        return false; // not invertible..    double inv[] = { 1. / a,  0.,       0.,      c / a,        0.,      1. / b,   0.,      d / b,        0.,      0.,       0.,      -1.,    0.,      0.,       1. / f,  e / f };    memcpy(n, inv, 4 * 4 * sizeof(double));    return true;}bool invert3x3(const float *ma, float *mb, bool transpose){    double da[9], db[9];    floats_to_doubles(ma, da, 9);    if (!invert3x3(da, db, transpose))        return false;    doubles_to_floats(db, mb, 9);    return true;}bool invert4x4(const float *ma, float *mb, bool transpose){    double da[16], db[16];    floats_to_doubles(ma, da, 16);    if (!invert4x4(da, db, transpose))        return false;    doubles_to_floats(db, mb, 16);    return true;}bool invert_projection4x4(const float *ma, float *mb){    double da[16], db[16];    floats_to_doubles(ma, da, 16);    if (!invert_projection4x4(da, db))        return false;    doubles_to_floats(db, mb, 16);    return true;}void scale4x4(double a, double b, double c, double d, double *m){    memset(m, 0, sizeof(double) * 16);    m[0] = a; m[5] = b; m[10] = c; m[15] = d;}void x_rotate4x4(double theta, double *m, bool rh){    double ct = cos(theta), st = rh ? -sin(theta) : sin(theta);        m[ 0] = 1.; m[ 1] = 0.; m[ 2] =  0.; m[ 3] = 0.;    m[ 4] = 0.; m[ 5] = ct; m[ 6] = -st; m[ 7] = 0.;    m[ 8] = 0.; m[ 9] = st; m[10] =  ct; m[11] = 0.;    m[12] = 0.; m[13] = 0.; m[14] =  0.; m[15] = 1.;}void y_rotate4x4(double theta, double *m, bool rh){    double ct = cos(theta), st = rh ? -sin(theta) : sin(theta);        m[ 0] =  ct; m[ 1] = 0.; m[ 2] = st; m[ 3] = 0.;    m[ 4] =  0.; m[ 5] = 1.; m[ 6] = 0.; m[ 7] = 0.;    m[ 8] = -st; m[ 9] = 0.; m[10] = ct; m[11] = 0.;    m[12] =  0.; m[13] = 0.; m[14] = 0.; m[15] = 1.;}void z_rotate4x4(double theta, double *m, bool rh){    double ct = cos(theta), st = rh ? -sin(theta) : sin(theta);        m[ 0] = ct; m[ 1] = -st; m[ 2] = 0.; m[ 3] = 0.;    m[ 4] = st; m[ 5] =  ct; m[ 6] = 0.; m[ 7] = 0.;    m[ 8] = 0.; m[ 9] =  0.; m[10] = 1.; m[11] = 0.;    m[12] = 0.; m[13] =  0.; m[14] = 0.; m[15] = 1.;}/* template <typename T> inline void Matrix4T<T>::lookat(const Tuple3T<T> &eye, const Tuple3T<T> &up, const Tuple3T<T> &at) { Tuple3T<T> zaxis = (at - eye).normalize(), xaxis = up.cross(zaxis).normalize(), yaxis = zaxis.cross(xaxis);  set(         xaxis.x,          yaxis.x,          zaxis.x, 0, xaxis.y,          yaxis.y,          zaxis.y, 0, xaxis.z,          yaxis.z,          zaxis.z, 0, -xaxis.dot(eye),  -yaxis.dot(eye),  -zaxis.dot(eye), 1); }  template <typename T> inline void Matrix4T<T>::reoriginate(const vec3_t &origin) { Matrix4T<T> n, m; m.translate(-origin); m *= *this; n.translate(origin);  m *= n; *this = m; }  template <typename T> inline void Matrix4T<T>::rotation(const vec3_t &s, const vec3_t &t) { if (s == t) { identity(); return; }  vec3_t cr(s.cross(t)); T e = s.dot(t), f = T(1) - e, g = cr.length(); vec3_t u(cr / g); /*  rotate vec s to vec t  where e == cos(2 * theta) == s.dot(t)            && f == 1 - e                                 && g == sin(2 * theta) == s.cross(t).length() && u == s.cross(t).normal();  e + f * u.x * u.x         f * u.x * u.y - g * u.z    f * u.x * u.z + g * u.y    0 f * u.x * u.y + g * u.z   e + f * u.y * u.y          f * u.y * u.z - g * u.x    0 f * u.x * u.z - g * u.y   f * u.y * u.z + g * u.x    e + f * u.z * u.z          0 0                         0                          0                          1  transposed:  * / set(e + f * u.x * u.x,        f * u.x * u.y + g * u.z,    f * u.x * u.z - g * u.y,    0, f * u.x * u.y - g * u.z,  e + f * u.y * u.y,          f * u.y * u.z + g * u.x,    0, f * u.x * u.z + g * u.y,  f * u.y * u.z - g * u.x,    e + f * u.z * u.z,          0, 0,                        0,                          0,                          1); }  #define _M(a, b) (*(((T *)data) + ((b) * 4 + (a))))  template <typename T> inline Matrix4T<T> &Matrix4T<T>::setTranslation(const Tuple3T<T> &p) { /* translate --  | r11 r12 r13 r11*x + r12*y + r13*z | | r21 r22 r23 r21*x + r22*y + r23*z | | r31 r32 r33 r31*x + r32*y + r33*z | |  0   0   0            1           | * / _M(3, 0) = _M(0, 0) * p.x + _M(1, 0) * p.y + _M(2, 0) * p.z; _M(3, 1) = _M(0, 1) * p.x + _M(1, 1) * p.y + _M(2, 1) * p.z; _M(3, 2) = _M(0, 2) * p.x + _M(1, 2) * p.y + _M(2, 2) * p.z; return *this; }  template <typename T> inline Tuple3T<T> &Matrix4T<T>::getTranslation(Tuple3T<T> &p) { /* translate --  | r11 r12 r13 r11*x + r12*y + r13*z | | r21 r22 r23 r21*x + r22*y + r23*z | | r31 r32 r33 r31*x + r32*y + r33*z | |  0   0   0            1           | * / p.x = _M(0, 0) * _M(3, 0) + _M(1, 0) * _M(3, 1) + _M(2, 0) * _M(3, 2); p.y = _M(0, 1) * _M(3, 0) + _M(1, 1) * _M(3, 1) + _M(2, 1) * _M(3, 2); p.z = _M(0, 2) * _M(3, 0) + _M(1, 2) * _M(3, 1) + _M(2, 2) * _M(3, 2); return p; }  template <typename T> inline void Matrix4T<T>::rotationx(T theta, bool rh) { m_rotx((T *)data, (T)cos(theta), (T)(rh ? -sin(theta) : sin(theta))); }  template <typename T> inline void Matrix4T<T>::rotationy(T theta, bool rh) { m_roty((T *)data, (T)cos(theta), (T)(rh ? -sin(theta) : sin(theta))); }  template <typename T> inline void Matrix4T<T>::rotationz(T theta, bool rh) { m_rotz((T *)data, (T)cos(theta), (T)(rh ? -sin(theta) : sin(theta))); }  template <typename T> inline void Matrix4T<T>::rotationaxis(const vec3_t &p, T theta, bool rh) { m_rotaxis((T *)data, p.x, p.y, p.z, (T)cos(theta), (T)(rh ? -sin(theta) : sin(theta))); }  // private implementation..   template <typename T> inline void Matrix4T<T>::m_rotaxis(T *m, T x, T y, T z, T cos_t, T sin_t) { T     t   = 1 - cos_t, sx  = sin_t * x, sy  = sin_t * y, sz  = sin_t * z, tx  = t     * x, ty  = t     * y, tz  = t     * z, txx = tx    * x, txy = tx    * y, tyy = ty    * y, tyz = ty    * z, tzz = tz    * z, txz = tx    * z;  *(m + 0)  = txx + cos_t; *(m + 1)  =  txy - sz;    *(m + 2)  = txz + sy;    *(m + 3)  = 0.0f; *(m + 4)  = txy + sz;    *(m + 5)  =  tyy + cos_t; *(m + 6)  = tyz - sx;    *(m + 7)  = 0.0f; *(m + 8)  = txz - sy;    *(m + 9)  =  tyz + sx;    *(m + 10) = tzz + cos_t; *(m + 11) = 0.0f; *(m + 12) = 0.0f;        *(m + 13) =  0.0f;        *(m + 14) = 0.0f;        *(m + 15) = 1.0f; }  template <typename T> inline void Matrix4T<T>::m_scale(T *m, T a, T b, T c, T d) { *(m + 0)  =  a;     *(m + 1)  =  0.0f;  *(m + 2)  =  0.0f;   *(m + 3)  = 0.0f; *(m + 4)  =  0.0f;  *(m + 5)  =  b;     *(m + 6)  =  0.0f;   *(m + 7)  = 0.0f; *(m + 8)  =  0.0f;  *(m + 9)  =  0.0f;  *(m + 10) =  c;      *(m + 11) = 0.0f; *(m + 12) =  0.0f;  *(m + 13) =  0.0f;  *(m + 14) =  0.0f;   *(m + 15) = d; }  template <typename T> inline void Matrix4T<T>::m_translate(T *m, T a, T b, T c) { *(m + 0)  =  1.0f;  *(m + 1)  =  0.0f;  *(m + 2)  =  0.0f;   *(m + 3)  = 0; *(m + 4)  =  0.0f;  *(m + 5)  =  1.0f;  *(m + 6)  =  0.0f;   *(m + 7)  = 0; *(m + 8)  =  0.0f;  *(m + 9)  =  0.0f;  *(m + 10) =  1.0f;   *(m + 11) = 0; *(m + 12) =     a;  *(m + 13) =     b;  *(m + 14) =     c;   *(m + 15) = 1.0f; }  template <typename T> inline void Matrix4T<T>::m_mvector4x4(T *v, const T *m, const T *u) { *(v + 0) = *(m + 0) * *(u + 0) + *(m + 4) * *(u + 1) + *(m + 8)  * *(u + 2) + *(m + 12) * *(u + 3); *(v + 1) = *(m + 1) * *(u + 0) + *(m + 5) * *(u + 1) + *(m + 9)  * *(u + 2) + *(m + 13) * *(u + 3); *(v + 2) = *(m + 2) * *(u + 0) + *(m + 6) * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 14) * *(u + 3); *(v + 3) = *(m + 3) * *(u + 0) + *(m + 7) * *(u + 1) + *(m + 11) * *(u + 2) + *(m + 15) * *(u + 3); }  template <typename T> inline void Matrix4T<T>::m_mvector4x4transpose(T *v, const T *m, const T *u) { *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 1)  * *(u + 1) + *(m + 2)  * *(u + 2) + *(m + 3)  * *(u + 3); *(v + 1) = *(m + 4)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 6)  * *(u + 2) + *(m + 7)  * *(u + 3); *(v + 2) = *(m + 8)  * *(u + 0) + *(m + 9)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 11) * *(u + 3); *(v + 3) = *(m + 12) * *(u + 0) + *(m + 13) * *(u + 1) + *(m + 14) * *(u + 2) + *(m + 15) * *(u + 3); }  template <typename T> inline void Matrix4T<T>::m_mvector4x3wn(T *v, const T *m, const T *u, float w) { *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 4)  * *(u + 1) + *(m + 8)  * *(u + 2) + *(m + 12) * w; *(v + 1) = *(m + 1)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 9)  * *(u + 2) + *(m + 13) * w; *(v + 2) = *(m + 2)  * *(u + 0) + *(m + 6)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 14) * w; }  template <typename T> inline void Matrix4T<T>::m_mvector4x3w1(T *v, const T *m, const T *u) { *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 4)  * *(u + 1) + *(m + 8)  * *(u + 2) + *(m + 12); *(v + 1) = *(m + 1)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 9)  * *(u + 2) + *(m + 13); *(v + 2) = *(m + 2)  * *(u + 0) + *(m + 6)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 14); }  template <typename T> inline void Matrix4T<T>::m_mvector4x3w0(T *v, const T *m, const T *u) { *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 4) * *(u + 1) + *(m + 8)  * *(u + 2); *(v + 1) = *(m + 1)  * *(u + 0) + *(m + 5) * *(u + 1) + *(m + 9)  * *(u + 2); *(v + 2) = *(m + 2)  * *(u + 0) + *(m + 6) * *(u + 1) + *(m + 10) * *(u + 2); }  template <typename T> inline void Matrix4T<T>::m_mvector4x3w1transpose(T *v, const T *m, const T *u) { *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 1)  * *(u + 1) + *(m + 2)  * *(u + 2) + *(m + 3); *(v + 1) = *(m + 4)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 6)  * *(u + 2) + *(m + 7); *(v + 2) = *(m + 8)  * *(u + 0) + *(m + 9)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 11); }  template <typename T> inline void Matrix4T<T>::m_mvector4x3wntranspose(T *v, const T *m, const T *u, float w) { *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 1)  * *(u + 1) + *(m + 2)  * *(u + 2) + *(m + 3) * w; *(v + 1) = *(m + 4)  * *(u + 0) + *(m + 5)  * *(u + 1) + *(m + 6)  * *(u + 2) + *(m + 7) * w; *(v + 2) = *(m + 8)  * *(u + 0) + *(m + 9)  * *(u + 1) + *(m + 10) * *(u + 2) + *(m + 11) * w; }  template <typename T> inline void Matrix4T<T>::m_mvector4x3w0transpose(T *v, const T *m, const T *u) { *(v + 0) = *(m + 0)  * *(u + 0) + *(m + 1) * *(u + 1) + *(m + 2)  * *(u + 2); *(v + 1) = *(m + 4)  * *(u + 0) + *(m + 5) * *(u + 1) + *(m + 6)  * *(u + 2); *(v + 2) = *(m + 8)  * *(u + 0) + *(m + 9) * *(u + 1) + *(m + 10) * *(u + 2); }  template <typename T> inline void Matrix4T<T>::m_mmatrix4transpose(T *m, const T *b, const T *a) { *(m + 0)  = *(b + 0)  * *(a + 0) + *(b + 1)  * *(a + 4) + *(b + 2)  * *(a + 8)  + *(b + 3)  * *(a + 12); *(m + 4)  = *(b + 0)  * *(a + 1) + *(b + 1)  * *(a + 5) + *(b + 2)  * *(a + 9)  + *(b + 3)  * *(a + 13); *(m + 8)  = *(b + 0)  * *(a + 2) + *(b + 1)  * *(a + 6) + *(b + 2)  * *(a + 10) + *(b + 3)  * *(a + 14); *(m + 12) = *(b + 0)  * *(a + 3) + *(b + 1)  * *(a + 7) + *(b + 2)  * *(a + 11) + *(b + 3)  * *(a + 15); *(m + 1)  = *(b + 4)  * *(a + 0) + *(b + 5)  * *(a + 4) + *(b + 6)  * *(a + 8)  + *(b + 7)  * *(a + 12); *(m + 5)  = *(b + 4)  * *(a + 1) + *(b + 5)  * *(a + 5) + *(b + 6)  * *(a + 9)  + *(b + 7)  * *(a + 13); *(m + 9)  = *(b + 4)  * *(a + 2) + *(b + 5)  * *(a + 6) + *(b + 6)  * *(a + 10) + *(b + 7)  * *(a + 14); *(m + 13) = *(b + 4)  * *(a + 3) + *(b + 5)  * *(a + 7) + *(b + 6)  * *(a + 11) + *(b + 7)  * *(a + 15); *(m + 2)  = *(b + 8)  * *(a + 0) + *(b + 9)  * *(a + 4) + *(b + 10) * *(a + 8)  + *(b + 11) * *(a + 12); *(m + 6)  = *(b + 8)  * *(a + 1) + *(b + 9)  * *(a + 5) + *(b + 10) * *(a + 9)  + *(b + 11) * *(a + 13); *(m + 10) = *(b + 8)  * *(a + 2) + *(b + 9)  * *(a + 6) + *(b + 10) * *(a + 10) + *(b + 11) * *(a + 14); *(m + 14) = *(b + 8)  * *(a + 3) + *(b + 9)  * *(a + 7) + *(b + 10) * *(a + 11) + *(b + 11) * *(a + 15); *(m + 3)  = *(b + 12) * *(a + 0) + *(b + 13) * *(a + 4) + *(b + 14) * *(a + 8)  + *(b + 15) * *(a + 12); *(m + 7)  = *(b + 12) * *(a + 1) + *(b + 13) * *(a + 5) + *(b + 14) * *(a + 9)  + *(b + 15) * *(a + 13); *(m + 11) = *(b + 12) * *(a + 2) + *(b + 13) * *(a + 6) + *(b + 14) * *(a + 10) + *(b + 15) * *(a + 14); *(m + 15) = *(b + 12) * *(a + 3) + *(b + 13) * *(a + 7) + *(b + 14) * *(a + 11) + *(b + 15) * *(a + 15); }  template <typename T> inline void Matrix4T<T>::m_mmatrix4(T *m, const T *a, const T *b) { *(m + 0)  = *(a + 0)  * *(b + 0) + *(a + 1)  * *(b + 4) + *(a + 2)  * *(b + 8)  + *(a + 3)  * *(b + 12); *(m + 1)  = *(a + 0)  * *(b + 1) + *(a + 1)  * *(b + 5) + *(a + 2)  * *(b + 9)  + *(a + 3)  * *(b + 13); *(m + 2)  = *(a + 0)  * *(b + 2) + *(a + 1)  * *(b + 6) + *(a + 2)  * *(b + 10) + *(a + 3)  * *(b + 14); *(m + 3)  = *(a + 0)  * *(b + 3) + *(a + 1)  * *(b + 7) + *(a + 2)  * *(b + 11) + *(a + 3)  * *(b + 15); *(m + 4)  = *(a + 4)  * *(b + 0) + *(a + 5)  * *(b + 4) + *(a + 6)  * *(b + 8)  + *(a + 7)  * *(b + 12); *(m + 5)  = *(a + 4)  * *(b + 1) + *(a + 5)  * *(b + 5) + *(a + 6)  * *(b + 9)  + *(a + 7)  * *(b + 13); *(m + 6)  = *(a + 4)  * *(b + 2) + *(a + 5)  * *(b + 6) + *(a + 6)  * *(b + 10) + *(a + 7)  * *(b + 14); *(m + 7)  = *(a + 4)  * *(b + 3) + *(a + 5)  * *(b + 7) + *(a + 6)  * *(b + 11) + *(a + 7)  * *(b + 15); *(m + 8)  = *(a + 8)  * *(b + 0) + *(a + 9)  * *(b + 4) + *(a + 10) * *(b + 8)  + *(a + 11) * *(b + 12); *(m + 9)  = *(a + 8)  * *(b + 1) + *(a + 9)  * *(b + 5) + *(a + 10) * *(b + 9)  + *(a + 11) * *(b + 13); *(m + 10) = *(a + 8)  * *(b + 2) + *(a + 9)  * *(b + 6) + *(a + 10) * *(b + 10) + *(a + 11) * *(b + 14); *(m + 11) = *(a + 8)  * *(b + 3) + *(a + 9)  * *(b + 7) + *(a + 10) * *(b + 11) + *(a + 11) * *(b + 15); *(m + 12) = *(a + 12) * *(b + 0) + *(a + 13) * *(b + 4) + *(a + 14) * *(b + 8)  + *(a + 15) * *(b + 12); *(m + 13) = *(a + 12) * *(b + 1) + *(a + 13) * *(b + 5) + *(a + 14) * *(b + 9)  + *(a + 15) * *(b + 13); *(m + 14) = *(a + 12) * *(b + 2) + *(a + 13) * *(b + 6) + *(a + 14) * *(b + 10) + *(a + 15) * *(b + 14); *(m + 15) = *(a + 12) * *(b + 3) + *(a + 13) * *(b + 7) + *(a + 14) * *(b + 11) + *(a + 15) * *(b + 15); }  template <typename T> inline void Matrix4T<T>::transpose() { T d[16]; d[0] = data[0];  d[4] = data[1];  d[8]  = data[2];  d[12] = data[3]; d[1] = data[4];  d[5] = data[5];  d[9]  = data[6];  d[13] = data[7]; d[2] = data[8];  d[6] = data[9];  d[10] = data[10]; d[14] = data[11]; d[3] = data[12]; d[7] = data[13]; d[11] = data[14]; d[15] = data[15]; memcpy((T *)data, (const T *)d, sizeof(d)); }  template <typename T> inline void Matrix4T<T>::diagonal(vec3_t &v) const { v.set(data[0], data[5], data[10]); }  template <typename T> inline void Matrix4T<T>::diagonal(vec4_t &v) const { v.set(data[0], data[5], data[10], data[15]); }  template <typename T> inline void Matrix4T<T>::flipcols(void) { T d[16]; d[0] = data[12]; d[4] = data[8];  d[8]  = data[4]; d[12] = data[0]; d[1] = data[13]; d[5] = data[9];  d[9]  = data[5]; d[13] = data[1]; d[2] = data[14]; d[6] = data[10]; d[10] = data[6]; d[14] = data[2]; d[3] = data[15]; d[7] = data[11]; d[11] = data[7]; d[15] = data[3]; memcpy((T *)data, (const T *)d, sizeof(d)); }  template <typename T> inline void Matrix4T<T>::fliprows(void) { T d[16]; d[0] = data[3]; d[4] = data[7]; d[8]  = data[11]; d[12] = data[15]; d[1] = data[2]; d[5] = data[6]; d[9]  = data[10]; d[13] = data[14]; d[2] = data[1]; d[6] = data[5]; d[10] = data[9];  d[14] = data[13]; d[3] = data[0]; d[7] = data[4]; d[11] = data[8];  d[15] = data[12]; memcpy((T *)data, (const T *)d, sizeof(d)); }  template <typename T> inline void Matrix4T<T>::clear(void) { memset(data, 0, sizeof(T) * 4 * 4); }  template <typename T> inline void Matrix4T<T>::fov(T fov, T aspectratio, T znear, T zfar, bool rh) { T h = (T)(cos(fov / 2) / sin(fov / 2)); perspective(h / aspectratio, h, znear, zfar, rh); }  template <typename T> inline void Matrix4T<T>::orthogonal(T w, T h, T znear, T zfar, bool rh) { T zd = znear - zfar; set(2 / w, 0,     0,          0, 0,     2 / h, 0,          0, 0,     0,     1 / zd,     0, 0,     0,     znear / zd, rh ? -1.0f : 1.0f); }  template <typename T> inline void Matrix4T<T>::perspective(T w, T h, T znear, T zfar, bool rh) { T zvol = zfar / (zfar - znear); set(w,  0,   0,            0, 0,  h,   0,            0, 0,  0,   zvol,         rh ? -1.0f : 1.0f, 0,  0,  -znear * zvol, 0); }   template <typename T> inline void Matrix4T<T>::reflect(const PlaneT<T> &p) { set(-2 * p.a * p.a + 1,  -2 * p.b * p.a,      -2 * p.c * p.a,       0, -2 * p.a * p.b,      -2 * p.b * p.b + 1,  -2 * p.c * p.b,       0, -2 * p.a * p.c,      -2 * p.b * p.c,      -2 * p.c * p.c + 1,   0, -2 * p.a * p.d,      -2 * p.b * p.d,      -2 * p.c * p.d,       1); }  template <typename T> inline void Matrix4T<T>::shadow(const vec3_t &light, const PlaneT<T> &plane, T vanish) { vec3_t pn(plane.normal); T d = light.dot(pn), dist = plane.dist; set(pn.x * light.x + d, pn.x * light.y,     pn.x * light.z,     pn.x * vanish, pn.y * light.x,     pn.y * light.y + d, pn.y * light.z,     pn.y * vanish, pn.z * light.x,     pn.z * light.y,     pn.z * light.z + d, pn.z * vanish, dist * light.x + d, dist * light.y,     dist * light.z,     dist * vanish); } */