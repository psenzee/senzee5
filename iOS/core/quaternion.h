#ifndef _QUATERNION_H#define _QUATERNION_H#include "tuple3f.h"#include "matrix4f.h"class Quaternion{public:            float x, y, z, w;        inline Quaternion()                                            : x(0.0f), y(0.0f), z(0.0f), w(1.0f) {}    inline Quaternion(float x, float y, float z, float w)          : x(x), y(y), z(z), w(w) {}    inline Quaternion(const Tuple3f &v, float w)                   : x(v.x), y(v.y), z(v.z), w(w) {}    inline Quaternion(const Quaternion &u)                         : x(u.x), y(u.y), z(u.z), w(u.w) {}            inline bool        operator==(const Quaternion &u)           const { return x == u.x && y == u.y && z == u.z && w == u.w; }    inline Quaternion &operator= (const Quaternion &u)                 { x = u.x; y = u.y; z = u.z; w = u.w; return *this; }    inline Quaternion  operator+ (const Quaternion &u)           const { return Quaternion(x + u.x, y + u.y, z + u.z, w + u.w); }    Quaternion         operator* (const Quaternion &u)           const;        inline Quaternion  operator* (float s)                       const { return Quaternion(s * x, s * y, s * z, s * w); }    inline Quaternion &operator*=(float s)                             { x *= s; y *= s; z *= s; w *= s; return *this; }    inline Quaternion &operator*=(const Quaternion &u)                 { *this = u * (*this); return *this; }            inline float  dot(const Quaternion &u)                       const { return x * u.x + y * u.y + z * u.z + w * u.w; }    inline void   invert()                                             { x = -x; y = -y; z = -z; }    inline void   set(float x, float y, float z, float w)              { this->x = x; this->y = y; this->z = z; this->w = w; }    inline void   set(const Tuple3f &v, float w)                       { x = v.x; y = v.y; z = v.z; this->w = w; }            inline Tuple3f xyz() const { return Tuple3f(x, y, z); }            Quaternion   &normalize();    Matrix4f      matrix()                                       const;    Quaternion    slerp(Quaternion a, Quaternion b, float time);            static Quaternion CreateFromAxisAngle(const Tuple3f &axis, float angle);};#endif  // _QUATERNION_H