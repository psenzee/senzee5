/* closed_class.c - autogenerated */

#include "closed_class.h"

#include <string.h>
#include <stdlib.h>

#ifndef WIN32
#define stricmp  strcasecmp
#define strnicmp strncasecmp
#endif

static size_t _closed_class_count          = 0;
static size_t _closed_class_maximum_length = 0;

static char  *_closed_class_buffer         = 0;

static const char *_closed_class_data[] =
{
    "'cause", "'n ", "'n'", "'til", "&", "&c", "a", "aboard", "about", "above",
    "across", "after", "against", "ago", "albeit", "all", "along", "alongside",
    "although", "always", "am", "amid", "among", "amongst", "an", "and", "any",
    "anybody", "anyhow", "anyone", "anything", "anytime", "anyway", "anywhere",
    "are", "aren't", "around", "as", "astride", "at", "atop", "be", "because",
    "been", "before", "behind", "being", "below", "beneath", "beside", "besides",
    "between", "beyond", "billion", "billionth", "both", "but", "by", "can",
    "can't", "cannot", "cause", "could", "couldn't", "de", "despite", "did", "do",
    "does", "doesn't", "doing", "don't", "done", "down", "during ", "each",
    "eight", "eighteen", "eighteenth", "eighth", "eightieth", "eighty", "either",
    "eleven", "eleventh", "enough", "etc.", "every", "everybody", "everyone",
    "everything", "everywhere", "except", "few", "fewer", "fifteen", "fifteenth",
    "fifth", "fiftieth", "fifty", "first", "five", "for", "fortieth", "forty",
    "four", "fourteen", "fourteenth", "fourth", "from", "had", "has", "have",
    "having", "he", "her", "here", "hers", "herself", "him", "himself", "his",
    "how", "hundred", "hundredth", "I", "i.e.", "I'm", "if", "in", "inside",
    "into", "is", "isn't", "it", "it's", "its", "itself", "least", "less", "lest",
    "like", "little", "many", "may", "me", "might", "million", "millionth", "mine",
    "minus ", "more", "most", "much", "must", "my", "myself", "near", "neither",
    "never", "nevertheless", "next", "nine", "nineteen", "nineteenth", "ninetieth",
    "ninety", "ninth", "no", "nobody", "none", "nor", "not", "nothing",
    "notwithstanding", "now", "nowhere", "of", "off", "on", "one", "oneself",
    "onto", "opposite", "or", "our", "ours", "ourselves", "out", "outside", "over",
    "par", "past", "per", "plus", "post", "quadrillion", "quadrillionth",
    "quintillion", "quintillionth", "second", "septillion", "septillionth",
    "seven", "seventeen", "seventeenth", "seventh", "seventieth", "seventy",
    "sextillion", "sextillionth", "shall", "she", "should", "since", "six",
    "sixteen", "sixteenth", "sixth", "sixtieth", "sixty", "so", "some", "somebody",
    "somehow", "someone", "something", "sometime", "somewhere", "ten", "tenth",
    "than", "that", "the", "thee", "their", "theirs", "them", "themselves", "then",
    "there", "these", "they", "they're", "thine", "third", "thirteen",
    "thirteenth", "thirtieth", "thirty", "this", "those", "thou", "though",
    "thousand", "thousandth", "three", "through", "throughout", "thy", "til",
    "till", "times", "to", "too", "toward", "towards", "trillion", "trillionth",
    "twelfth", "twelve", "twentieth", "twenty", "two", "under", "underneath",
    "unless", "unlike", "until", "unto", "up", "upon", "us", "v.", "versus", "via",
    "vs.", "was", "we", "were", "weren't", "what", "when", "where", "whereas",
    "whether", "which", "while", "who", "whom", "whose", "why", "will", "willing",
    "with", "within", "without", "won't", "worth", "would", "wouldn't", "y'all",
    "ye", "yes", "yet", "you", "you all", "you'ns", "you're", "youns", "your",
    "yours", "yourself", "yourselves", "yous", "youse", "zero",
NULL
};

static int _closed_class_compare_ascend(const void *a, const void *b)
{
    const char *p = *(const char **)a, *q = *(const char **)b;
    return stricmp(p, q);
}

static void _closed_class_initialize(void)
{
    if (!_closed_class_count)
    {
        size_t count = 0, length = 0;
        const char **p = (const char **)_closed_class_data;
        while (*p)
        {
            size_t len = strlen(*p);
            if (len > length)
                length = len;
            count++;
            p++;
        }
        _closed_class_count          = count;
        _closed_class_maximum_length = length;
        _closed_class_buffer         = (char *)malloc(sizeof(char *) * (length + 2));
        memset(_closed_class_buffer, 0, length + 2);
    }
}

size_t closed_class_count(void)
{
    _closed_class_initialize();
    return _closed_class_count;
}

size_t closed_class_maximum_length(void)
{
    _closed_class_initialize();
    return _closed_class_maximum_length;
}

const char *closed_class_string_at(size_t index)
{
    if (index >= closed_class_count())
        return NULL;
    return _closed_class_data[index];
}

const char *closed_class_contains(const char *str)
{
    if (!str || !*str || strlen(str) > closed_class_maximum_length())
        return 0;

    const char **find = (const char **)&str;
    char **found = (char **)bsearch(find, _closed_class_data,
                                    closed_class_count(), sizeof(const char *),
                                    _closed_class_compare_ascend);
    return found ? *found : NULL;
}

const char *closed_class_starts_with(const char *str)
{
    size_t length = strlen(str);
    if (length > closed_class_maximum_length())
        length = closed_class_maximum_length();
    strcpy(_closed_class_buffer, str);
    while (length > 0)
    {
        _closed_class_buffer[length] = '\0';
        const char *found = closed_class_contains(_closed_class_buffer);
        if (found)
            return found;
        length--;
    }
    return NULL;
}

const char *closed_class_ends_with(const char *str)
{
    const char *p = str;
    while (*p && *(p + 1))
    {
        const char *found = closed_class_contains(p);
        if (found && strlen(found) == strlen(p))
            return found;
        p++;
    }
    return NULL;
}
